; ModuleID = 'djpeg.c'
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-apple-macosx10.9.0"

%struct.__sFILE = type { i8*, i32, i32, i16, i16, %struct.__sbuf, i32, i8*, i32 (i8*)*, i32 (i8*, i8*, i32)*, i64 (i8*, i64, i32)*, i32 (i8*, i8*, i32)*, %struct.__sbuf, %struct.__sFILEX*, i32, [3 x i8], [1 x i8], %struct.__sbuf, i32, i64 }
%struct.__sbuf = type { i8*, i32 }
%struct.__sFILEX = type opaque
%struct.jpeg_decompress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_source_mgr*, i32, i32, i32, i32, i32, i32, i32, double, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8**, i32, i32, i32, i32, i32, [64 x i32]*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], i32, %struct.jpeg_component_info*, i32, i32, [16 x i8], [16 x i8], [16 x i8], i32, i32, i8, i16, i16, i32, i8, i32, i32, i32, i32, i32, i8*, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, i32, %struct.jpeg_decomp_master*, %struct.jpeg_d_main_controller*, %struct.jpeg_d_coef_controller*, %struct.jpeg_d_post_controller*, %struct.jpeg_input_controller*, %struct.jpeg_marker_reader*, %struct.jpeg_entropy_decoder*, %struct.jpeg_inverse_dct*, %struct.jpeg_upsampler*, %struct.jpeg_color_deconverter*, %struct.jpeg_color_quantizer* }
%struct.jpeg_error_mgr = type { void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*, i32)*, void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*, i8*)*, void (%struct.jpeg_common_struct*)*, i32, %union.anon, i32, i64, i8**, i32, i8**, i32, i32 }
%struct.jpeg_common_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32 }
%struct.jpeg_memory_mgr = type { i8* (%struct.jpeg_common_struct*, i32, i64)*, i8* (%struct.jpeg_common_struct*, i32, i64)*, i8** (%struct.jpeg_common_struct*, i32, i32, i32)*, [64 x i16]** (%struct.jpeg_common_struct*, i32, i32, i32)*, %struct.jvirt_sarray_control* (%struct.jpeg_common_struct*, i32, i32, i32, i32, i32)*, %struct.jvirt_barray_control* (%struct.jpeg_common_struct*, i32, i32, i32, i32, i32)*, {}*, i8** (%struct.jpeg_common_struct*, %struct.jvirt_sarray_control*, i32, i32, i32)*, [64 x i16]** (%struct.jpeg_common_struct*, %struct.jvirt_barray_control*, i32, i32, i32)*, void (%struct.jpeg_common_struct*, i32)*, {}*, i64 }
%struct.jvirt_sarray_control = type opaque
%struct.jvirt_barray_control = type opaque
%struct.jpeg_progress_mgr = type { {}*, i64, i64, i32, i32 }
%union.anon = type { [8 x i32], [48 x i8] }
%struct.jpeg_source_mgr = type { i8*, i64, void (%struct.jpeg_decompress_struct*)*, i32 (%struct.jpeg_decompress_struct*)*, void (%struct.jpeg_decompress_struct*, i64)*, i32 (%struct.jpeg_decompress_struct*, i32)*, void (%struct.jpeg_decompress_struct*)* }
%struct.JQUANT_TBL = type { [64 x i16], i32 }
%struct.JHUFF_TBL = type { [17 x i8], [256 x i8], i32 }
%struct.jpeg_component_info = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.JQUANT_TBL*, i8* }
%struct.jpeg_decomp_master = type opaque
%struct.jpeg_d_main_controller = type opaque
%struct.jpeg_d_coef_controller = type opaque
%struct.jpeg_d_post_controller = type opaque
%struct.jpeg_input_controller = type opaque
%struct.jpeg_marker_reader = type opaque
%struct.jpeg_entropy_decoder = type opaque
%struct.jpeg_inverse_dct = type opaque
%struct.jpeg_upsampler = type opaque
%struct.jpeg_color_deconverter = type opaque
%struct.jpeg_color_quantizer = type opaque
%struct.djpeg_dest_struct = type { void (%struct.jpeg_decompress_struct*, %struct.djpeg_dest_struct*)*, void (%struct.jpeg_decompress_struct*, %struct.djpeg_dest_struct*, i32)*, void (%struct.jpeg_decompress_struct*, %struct.djpeg_dest_struct*)*, %struct.__sFILE*, i8**, i32 }

@progname = internal global i8* null, align 8
@.str = private unnamed_addr constant [6 x i8] c"djpeg\00", align 1
@cdjpeg_message_table = internal constant [44 x i8*] [i8* null, i8* getelementptr inbounds ([32 x i8]* @.str71, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8]* @.str72, i32 0, i32 0), i8* getelementptr inbounds ([36 x i8]* @.str73, i32 0, i32 0), i8* getelementptr inbounds ([42 x i8]* @.str74, i32 0, i32 0), i8* getelementptr inbounds ([36 x i8]* @.str75, i32 0, i32 0), i8* getelementptr inbounds ([41 x i8]* @.str76, i32 0, i32 0), i8* getelementptr inbounds ([40 x i8]* @.str77, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8]* @.str78, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8]* @.str79, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8]* @.str80, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8]* @.str81, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8]* @.str82, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8]* @.str83, i32 0, i32 0), i8* getelementptr inbounds ([36 x i8]* @.str84, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8]* @.str85, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8]* @.str86, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8]* @.str87, i32 0, i32 0), i8* getelementptr inbounds ([48 x i8]* @.str88, i32 0, i32 0), i8* getelementptr inbounds ([44 x i8]* @.str89, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8]* @.str90, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8]* @.str91, i32 0, i32 0), i8* getelementptr inbounds ([40 x i8]* @.str92, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8]* @.str93, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8]* @.str94, i32 0, i32 0), i8* getelementptr inbounds ([36 x i8]* @.str95, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8]* @.str96, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8]* @.str97, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8]* @.str98, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8]* @.str99, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8]* @.str100, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8]* @.str101, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8]* @.str102, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8]* @.str103, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8]* @.str104, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8]* @.str105, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8]* @.str106, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8]* @.str107, i32 0, i32 0), i8* getelementptr inbounds ([51 x i8]* @.str108, i32 0, i32 0), i8* getelementptr inbounds ([53 x i8]* @.str109, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8]* @.str110, i32 0, i32 0), i8* getelementptr inbounds ([59 x i8]* @.str111, i32 0, i32 0), i8* getelementptr inbounds ([31 x i8]* @.str112, i32 0, i32 0), i8* null], align 16
@__stderrp = external global %struct.__sFILE*
@.str1 = private unnamed_addr constant [25 x i8] c"%s: only one input file\0A\00", align 1
@.str2 = private unnamed_addr constant [3 x i8] c"rb\00", align 1
@.str3 = private unnamed_addr constant [19 x i8] c"%s: can't open %s\0A\00", align 1
@outfilename = internal global i8* null, align 8
@.str4 = private unnamed_addr constant [3 x i8] c"wb\00", align 1
@requested_fmt = internal global i32 0, align 4
@__stdinp = external global %struct.__sFILE*
@__stdoutp = external global %struct.__sFILE*
@.str5 = private unnamed_addr constant [22 x i8] c"usage: %s [switches] \00", align 1
@.str6 = private unnamed_addr constant [13 x i8] c"[inputfile]\0A\00", align 1
@.str7 = private unnamed_addr constant [38 x i8] c"Switches (names may be abbreviated):\0A\00", align 1
@.str8 = private unnamed_addr constant [56 x i8] c"  -colors N      Reduce image to no more than N colors\0A\00", align 1
@.str9 = private unnamed_addr constant [47 x i8] c"  -fast          Fast, low-quality processing\0A\00", align 1
@.str10 = private unnamed_addr constant [41 x i8] c"  -grayscale     Force grayscale output\0A\00", align 1
@.str11 = private unnamed_addr constant [62 x i8] c"  -scale M/N     Scale output image by fraction M/N, eg, 1/8\0A\00", align 1
@.str12 = private unnamed_addr constant [61 x i8] c"  -bmp           Select BMP output format (Windows style)%s\0A\00", align 1
@.str13 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str14 = private unnamed_addr constant [45 x i8] c"  -gif           Select GIF output format%s\0A\00", align 1
@.str15 = private unnamed_addr constant [58 x i8] c"  -os2           Select BMP output format (OS/2 style)%s\0A\00", align 1
@.str16 = private unnamed_addr constant [59 x i8] c"  -pnm           Select PBMPLUS (PPM/PGM) output format%s\0A\00", align 1
@.str17 = private unnamed_addr constant [11 x i8] c" (default)\00", align 1
@.str18 = private unnamed_addr constant [47 x i8] c"  -targa         Select Targa output format%s\0A\00", align 1
@.str19 = private unnamed_addr constant [30 x i8] c"Switches for advanced users:\0A\00", align 1
@.str20 = private unnamed_addr constant [43 x i8] c"  -dct int       Use integer DCT method%s\0A\00", align 1
@.str21 = private unnamed_addr constant [57 x i8] c"  -dct fast      Use fast integer DCT (less accurate)%s\0A\00", align 1
@.str22 = private unnamed_addr constant [50 x i8] c"  -dct float     Use floating-point DCT method%s\0A\00", align 1
@.str23 = private unnamed_addr constant [46 x i8] c"  -dither fs     Use F-S dithering (default)\0A\00", align 1
@.str24 = private unnamed_addr constant [54 x i8] c"  -dither none   Don't use dithering in quantization\0A\00", align 1
@.str25 = private unnamed_addr constant [63 x i8] c"  -dither ordered  Use ordered dither (medium speed, quality)\0A\00", align 1
@.str26 = private unnamed_addr constant [57 x i8] c"  -map FILE      Map to colors used in named image file\0A\00", align 1
@.str27 = private unnamed_addr constant [52 x i8] c"  -nosmooth      Don't use high-quality upsampling\0A\00", align 1
@.str28 = private unnamed_addr constant [62 x i8] c"  -onepass       Use 1-pass quantization (fast, low quality)\0A\00", align 1
@.str29 = private unnamed_addr constant [52 x i8] c"  -maxmemory N   Maximum memory to use (in kbytes)\0A\00", align 1
@.str30 = private unnamed_addr constant [47 x i8] c"  -outfile name  Specify name for output file\0A\00", align 1
@.str31 = private unnamed_addr constant [44 x i8] c"  -verbose  or  -debug   Emit debug output\0A\00", align 1
@.str32 = private unnamed_addr constant [4 x i8] c"bmp\00", align 1
@.str33 = private unnamed_addr constant [7 x i8] c"colors\00", align 1
@.str34 = private unnamed_addr constant [8 x i8] c"colours\00", align 1
@.str35 = private unnamed_addr constant [9 x i8] c"quantize\00", align 1
@.str36 = private unnamed_addr constant [9 x i8] c"quantise\00", align 1
@.str37 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str38 = private unnamed_addr constant [4 x i8] c"dct\00", align 1
@.str39 = private unnamed_addr constant [4 x i8] c"int\00", align 1
@.str40 = private unnamed_addr constant [5 x i8] c"fast\00", align 1
@.str41 = private unnamed_addr constant [6 x i8] c"float\00", align 1
@.str42 = private unnamed_addr constant [7 x i8] c"dither\00", align 1
@.str43 = private unnamed_addr constant [3 x i8] c"fs\00", align 1
@.str44 = private unnamed_addr constant [5 x i8] c"none\00", align 1
@.str45 = private unnamed_addr constant [8 x i8] c"ordered\00", align 1
@.str46 = private unnamed_addr constant [6 x i8] c"debug\00", align 1
@.str47 = private unnamed_addr constant [8 x i8] c"verbose\00", align 1
@parse_switches.printed_version = internal global i32 0, align 4
@.str48 = private unnamed_addr constant [47 x i8] c"Independent JPEG Group's DJPEG, version %s\0A%s\0A\00", align 1
@.str49 = private unnamed_addr constant [13 x i8] c"6a  7-Feb-96\00", align 1
@.str50 = private unnamed_addr constant [35 x i8] c"Copyright (C) 1996, Thomas G. Lane\00", align 1
@.str51 = private unnamed_addr constant [4 x i8] c"gif\00", align 1
@.str52 = private unnamed_addr constant [10 x i8] c"grayscale\00", align 1
@.str53 = private unnamed_addr constant [10 x i8] c"greyscale\00", align 1
@.str54 = private unnamed_addr constant [4 x i8] c"map\00", align 1
@.str55 = private unnamed_addr constant [10 x i8] c"maxmemory\00", align 1
@.str56 = private unnamed_addr constant [6 x i8] c"%ld%c\00", align 1
@.str57 = private unnamed_addr constant [9 x i8] c"nosmooth\00", align 1
@.str58 = private unnamed_addr constant [8 x i8] c"onepass\00", align 1
@.str59 = private unnamed_addr constant [4 x i8] c"os2\00", align 1
@.str60 = private unnamed_addr constant [8 x i8] c"outfile\00", align 1
@.str61 = private unnamed_addr constant [4 x i8] c"pnm\00", align 1
@.str62 = private unnamed_addr constant [4 x i8] c"ppm\00", align 1
@.str63 = private unnamed_addr constant [4 x i8] c"rle\00", align 1
@.str64 = private unnamed_addr constant [6 x i8] c"scale\00", align 1
@.str65 = private unnamed_addr constant [6 x i8] c"%d/%d\00", align 1
@.str66 = private unnamed_addr constant [6 x i8] c"targa\00", align 1
@.str67 = private unnamed_addr constant [22 x i8] c"Comment, length %ld:\0A\00", align 1
@.str68 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str69 = private unnamed_addr constant [3 x i8] c"\5C\5C\00", align 1
@.str70 = private unnamed_addr constant [6 x i8] c"\5C%03o\00", align 1
@.str71 = private unnamed_addr constant [32 x i8] c"Unsupported BMP colormap format\00", align 1
@.str72 = private unnamed_addr constant [43 x i8] c"Only 8- and 24-bit BMP files are supported\00", align 1
@.str73 = private unnamed_addr constant [36 x i8] c"Invalid BMP file: bad header length\00", align 1
@.str74 = private unnamed_addr constant [42 x i8] c"Invalid BMP file: biPlanes not equal to 1\00", align 1
@.str75 = private unnamed_addr constant [36 x i8] c"BMP output must be grayscale or RGB\00", align 1
@.str76 = private unnamed_addr constant [41 x i8] c"Sorry, compressed BMPs not yet supported\00", align 1
@.str77 = private unnamed_addr constant [40 x i8] c"Not a BMP file - does not start with BM\00", align 1
@.str78 = private unnamed_addr constant [23 x i8] c"%ux%u 24-bit BMP image\00", align 1
@.str79 = private unnamed_addr constant [34 x i8] c"%ux%u 8-bit colormapped BMP image\00", align 1
@.str80 = private unnamed_addr constant [27 x i8] c"%ux%u 24-bit OS2 BMP image\00", align 1
@.str81 = private unnamed_addr constant [38 x i8] c"%ux%u 8-bit colormapped OS2 BMP image\00", align 1
@.str82 = private unnamed_addr constant [24 x i8] c"GIF output got confused\00", align 1
@.str83 = private unnamed_addr constant [22 x i8] c"Bogus GIF codesize %d\00", align 1
@.str84 = private unnamed_addr constant [36 x i8] c"GIF output must be grayscale or RGB\00", align 1
@.str85 = private unnamed_addr constant [27 x i8] c"Too few images in GIF file\00", align 1
@.str86 = private unnamed_addr constant [15 x i8] c"Not a GIF file\00", align 1
@.str87 = private unnamed_addr constant [19 x i8] c"%ux%ux%d GIF image\00", align 1
@.str88 = private unnamed_addr constant [48 x i8] c"Warning: unexpected GIF version number '%c%c%c'\00", align 1
@.str89 = private unnamed_addr constant [44 x i8] c"Ignoring GIF extension block of type 0x%02x\00", align 1
@.str90 = private unnamed_addr constant [35 x i8] c"Caution: nonsquare pixels in input\00", align 1
@.str91 = private unnamed_addr constant [25 x i8] c"Corrupt data in GIF file\00", align 1
@.str92 = private unnamed_addr constant [40 x i8] c"Bogus char 0x%02x in GIF file, ignoring\00", align 1
@.str93 = private unnamed_addr constant [27 x i8] c"Premature end of GIF image\00", align 1
@.str94 = private unnamed_addr constant [20 x i8] c"Ran out of GIF bits\00", align 1
@.str95 = private unnamed_addr constant [36 x i8] c"PPM output must be grayscale or RGB\00", align 1
@.str96 = private unnamed_addr constant [28 x i8] c"Nonnumeric data in PPM file\00", align 1
@.str97 = private unnamed_addr constant [15 x i8] c"Not a PPM file\00", align 1
@.str98 = private unnamed_addr constant [16 x i8] c"%ux%u PGM image\00", align 1
@.str99 = private unnamed_addr constant [21 x i8] c"%ux%u text PGM image\00", align 1
@.str100 = private unnamed_addr constant [16 x i8] c"%ux%u PPM image\00", align 1
@.str101 = private unnamed_addr constant [21 x i8] c"%ux%u text PPM image\00", align 1
@.str102 = private unnamed_addr constant [34 x i8] c"Unsupported Targa colormap format\00", align 1
@.str103 = private unnamed_addr constant [34 x i8] c"Invalid or unsupported Targa file\00", align 1
@.str104 = private unnamed_addr constant [38 x i8] c"Targa output must be grayscale or RGB\00", align 1
@.str105 = private unnamed_addr constant [22 x i8] c"%ux%u RGB Targa image\00", align 1
@.str106 = private unnamed_addr constant [28 x i8] c"%ux%u grayscale Targa image\00", align 1
@.str107 = private unnamed_addr constant [30 x i8] c"%ux%u colormapped Targa image\00", align 1
@.str108 = private unnamed_addr constant [51 x i8] c"Color map file is invalid or of unsupported format\00", align 1
@.str109 = private unnamed_addr constant [53 x i8] c"Output file format cannot handle %d colormap entries\00", align 1
@.str110 = private unnamed_addr constant [14 x i8] c"ungetc failed\00", align 1
@.str111 = private unnamed_addr constant [59 x i8] c"Unrecognized input file format --- perhaps you need -targa\00", align 1
@.str112 = private unnamed_addr constant [31 x i8] c"Unsupported output file format\00", align 1

; Function Attrs: nounwind ssp uwtable
define i32 @main(i32 %argc, i8** %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  %cinfo = alloca %struct.jpeg_decompress_struct, align 8
  %jerr = alloca %struct.jpeg_error_mgr, align 8
  %file_index = alloca i32, align 4
  %dest_mgr = alloca %struct.djpeg_dest_struct*, align 8
  %input_file = alloca %struct.__sFILE*, align 8
  %output_file = alloca %struct.__sFILE*, align 8
  %num_scanlines = alloca i32, align 4
  store i32 0, i32* %retval
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  store %struct.djpeg_dest_struct* null, %struct.djpeg_dest_struct** %dest_mgr, align 8
  %0 = load i8*** %argv.addr, align 8
  %arrayidx = getelementptr inbounds i8** %0, i64 0
  %1 = load i8** %arrayidx, align 8
  store i8* %1, i8** @progname, align 8
  %2 = load i8** @progname, align 8
  %cmp = icmp eq i8* %2, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load i8** @progname, align 8
  %arrayidx1 = getelementptr inbounds i8* %3, i64 0
  %4 = load i8* %arrayidx1, align 1
  %conv = sext i8 %4 to i32
  %cmp2 = icmp eq i32 %conv, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i8* getelementptr inbounds ([6 x i8]* @.str, i32 0, i32 0), i8** @progname, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %call = call %struct.jpeg_error_mgr* @jpeg_std_error(%struct.jpeg_error_mgr* %jerr)
  %err = getelementptr inbounds %struct.jpeg_decompress_struct* %cinfo, i32 0, i32 0
  store %struct.jpeg_error_mgr* %call, %struct.jpeg_error_mgr** %err, align 8
  call void @jpeg_CreateDecompress(%struct.jpeg_decompress_struct* %cinfo, i32 61, i64 616)
  %addon_message_table = getelementptr inbounds %struct.jpeg_error_mgr* %jerr, i32 0, i32 11
  store i8** getelementptr inbounds ([44 x i8*]* @cdjpeg_message_table, i32 0, i32 0), i8*** %addon_message_table, align 8
  %first_addon_message = getelementptr inbounds %struct.jpeg_error_mgr* %jerr, i32 0, i32 12
  store i32 1000, i32* %first_addon_message, align 4
  %last_addon_message = getelementptr inbounds %struct.jpeg_error_mgr* %jerr, i32 0, i32 13
  store i32 1043, i32* %last_addon_message, align 4
  call void @jpeg_set_marker_processor(%struct.jpeg_decompress_struct* %cinfo, i32 254, i32 (%struct.jpeg_decompress_struct*)* @COM_handler)
  %5 = load i32* %argc.addr, align 4
  %6 = load i8*** %argv.addr, align 8
  %call4 = call i32 @parse_switches(%struct.jpeg_decompress_struct* %cinfo, i32 %5, i8** %6, i32 0, i32 0)
  store i32 %call4, i32* %file_index, align 4
  %7 = load i32* %file_index, align 4
  %8 = load i32* %argc.addr, align 4
  %sub = sub nsw i32 %8, 1
  %cmp5 = icmp slt i32 %7, %sub
  br i1 %cmp5, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.end
  %9 = load %struct.__sFILE** @__stderrp, align 8
  %10 = load i8** @progname, align 8
  %call8 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %9, i8* getelementptr inbounds ([25 x i8]* @.str1, i32 0, i32 0), i8* %10)
  call void @usage()
  br label %if.end9

if.end9:                                          ; preds = %if.then7, %if.end
  %11 = load i32* %file_index, align 4
  %12 = load i32* %argc.addr, align 4
  %cmp10 = icmp slt i32 %11, %12
  br i1 %cmp10, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end9
  %13 = load i32* %file_index, align 4
  %idxprom = sext i32 %13 to i64
  %14 = load i8*** %argv.addr, align 8
  %arrayidx13 = getelementptr inbounds i8** %14, i64 %idxprom
  %15 = load i8** %arrayidx13, align 8
  %call14 = call %struct.__sFILE* @"\01_fopen"(i8* %15, i8* getelementptr inbounds ([3 x i8]* @.str2, i32 0, i32 0))
  store %struct.__sFILE* %call14, %struct.__sFILE** %input_file, align 8
  %cmp15 = icmp eq %struct.__sFILE* %call14, null
  br i1 %cmp15, label %if.then17, label %if.end21

if.then17:                                        ; preds = %if.then12
  %16 = load %struct.__sFILE** @__stderrp, align 8
  %17 = load i8** @progname, align 8
  %18 = load i32* %file_index, align 4
  %idxprom18 = sext i32 %18 to i64
  %19 = load i8*** %argv.addr, align 8
  %arrayidx19 = getelementptr inbounds i8** %19, i64 %idxprom18
  %20 = load i8** %arrayidx19, align 8
  %call20 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %16, i8* getelementptr inbounds ([19 x i8]* @.str3, i32 0, i32 0), i8* %17, i8* %20)
  call void @exit(i32 1) #3
  unreachable

if.end21:                                         ; preds = %if.then12
  br label %if.end23

if.else:                                          ; preds = %if.end9
  %call22 = call %struct.__sFILE* @read_stdin()
  store %struct.__sFILE* %call22, %struct.__sFILE** %input_file, align 8
  br label %if.end23

if.end23:                                         ; preds = %if.else, %if.end21
  %21 = load i8** @outfilename, align 8
  %cmp24 = icmp ne i8* %21, null
  br i1 %cmp24, label %if.then26, label %if.else33

if.then26:                                        ; preds = %if.end23
  %22 = load i8** @outfilename, align 8
  %call27 = call %struct.__sFILE* @"\01_fopen"(i8* %22, i8* getelementptr inbounds ([3 x i8]* @.str4, i32 0, i32 0))
  store %struct.__sFILE* %call27, %struct.__sFILE** %output_file, align 8
  %cmp28 = icmp eq %struct.__sFILE* %call27, null
  br i1 %cmp28, label %if.then30, label %if.end32

if.then30:                                        ; preds = %if.then26
  %23 = load %struct.__sFILE** @__stderrp, align 8
  %24 = load i8** @progname, align 8
  %25 = load i8** @outfilename, align 8
  %call31 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %23, i8* getelementptr inbounds ([19 x i8]* @.str3, i32 0, i32 0), i8* %24, i8* %25)
  call void @exit(i32 1) #3
  unreachable

if.end32:                                         ; preds = %if.then26
  br label %if.end35

if.else33:                                        ; preds = %if.end23
  %call34 = call %struct.__sFILE* @write_stdout()
  store %struct.__sFILE* %call34, %struct.__sFILE** %output_file, align 8
  br label %if.end35

if.end35:                                         ; preds = %if.else33, %if.end32
  %26 = load %struct.__sFILE** %input_file, align 8
  call void @jpeg_stdio_src(%struct.jpeg_decompress_struct* %cinfo, %struct.__sFILE* %26)
  %call36 = call i32 @jpeg_read_header(%struct.jpeg_decompress_struct* %cinfo, i32 1)
  %27 = load i32* %argc.addr, align 4
  %28 = load i8*** %argv.addr, align 8
  %call37 = call i32 @parse_switches(%struct.jpeg_decompress_struct* %cinfo, i32 %27, i8** %28, i32 0, i32 1)
  store i32 %call37, i32* %file_index, align 4
  %29 = load i32* @requested_fmt, align 4
  switch i32 %29, label %sw.default [
    i32 0, label %sw.bb
    i32 2, label %sw.bb39
    i32 1, label %sw.bb41
    i32 3, label %sw.bb43
    i32 5, label %sw.bb45
  ]

sw.bb:                                            ; preds = %if.end35
  %call38 = call %struct.djpeg_dest_struct* @jinit_write_bmp(%struct.jpeg_decompress_struct* %cinfo, i32 0)
  store %struct.djpeg_dest_struct* %call38, %struct.djpeg_dest_struct** %dest_mgr, align 8
  br label %sw.epilog

sw.bb39:                                          ; preds = %if.end35
  %call40 = call %struct.djpeg_dest_struct* @jinit_write_bmp(%struct.jpeg_decompress_struct* %cinfo, i32 1)
  store %struct.djpeg_dest_struct* %call40, %struct.djpeg_dest_struct** %dest_mgr, align 8
  br label %sw.epilog

sw.bb41:                                          ; preds = %if.end35
  %call42 = call %struct.djpeg_dest_struct* @jinit_write_gif(%struct.jpeg_decompress_struct* %cinfo)
  store %struct.djpeg_dest_struct* %call42, %struct.djpeg_dest_struct** %dest_mgr, align 8
  br label %sw.epilog

sw.bb43:                                          ; preds = %if.end35
  %call44 = call %struct.djpeg_dest_struct* @jinit_write_ppm(%struct.jpeg_decompress_struct* %cinfo)
  store %struct.djpeg_dest_struct* %call44, %struct.djpeg_dest_struct** %dest_mgr, align 8
  br label %sw.epilog

sw.bb45:                                          ; preds = %if.end35
  %call46 = call %struct.djpeg_dest_struct* @jinit_write_targa(%struct.jpeg_decompress_struct* %cinfo)
  store %struct.djpeg_dest_struct* %call46, %struct.djpeg_dest_struct** %dest_mgr, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %if.end35
  %err47 = getelementptr inbounds %struct.jpeg_decompress_struct* %cinfo, i32 0, i32 0
  %30 = load %struct.jpeg_error_mgr** %err47, align 8
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr* %30, i32 0, i32 5
  store i32 1042, i32* %msg_code, align 4
  %err48 = getelementptr inbounds %struct.jpeg_decompress_struct* %cinfo, i32 0, i32 0
  %31 = load %struct.jpeg_error_mgr** %err48, align 8
  %error_exit = getelementptr inbounds %struct.jpeg_error_mgr* %31, i32 0, i32 0
  %32 = load void (%struct.jpeg_common_struct*)** %error_exit, align 8
  %33 = bitcast %struct.jpeg_decompress_struct* %cinfo to %struct.jpeg_common_struct*
  call void %32(%struct.jpeg_common_struct* %33)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb45, %sw.bb43, %sw.bb41, %sw.bb39, %sw.bb
  %34 = load %struct.__sFILE** %output_file, align 8
  %35 = load %struct.djpeg_dest_struct** %dest_mgr, align 8
  %output_file49 = getelementptr inbounds %struct.djpeg_dest_struct* %35, i32 0, i32 3
  store %struct.__sFILE* %34, %struct.__sFILE** %output_file49, align 8
  %call50 = call i32 @jpeg_start_decompress(%struct.jpeg_decompress_struct* %cinfo)
  %36 = load %struct.djpeg_dest_struct** %dest_mgr, align 8
  %start_output = getelementptr inbounds %struct.djpeg_dest_struct* %36, i32 0, i32 0
  %37 = load void (%struct.jpeg_decompress_struct*, %struct.djpeg_dest_struct*)** %start_output, align 8
  %38 = load %struct.djpeg_dest_struct** %dest_mgr, align 8
  call void %37(%struct.jpeg_decompress_struct* %cinfo, %struct.djpeg_dest_struct* %38)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %sw.epilog
  %output_scanline = getelementptr inbounds %struct.jpeg_decompress_struct* %cinfo, i32 0, i32 33
  %39 = load i32* %output_scanline, align 4
  %output_height = getelementptr inbounds %struct.jpeg_decompress_struct* %cinfo, i32 0, i32 27
  %40 = load i32* %output_height, align 4
  %cmp51 = icmp ult i32 %39, %40
  br i1 %cmp51, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %41 = load %struct.djpeg_dest_struct** %dest_mgr, align 8
  %buffer = getelementptr inbounds %struct.djpeg_dest_struct* %41, i32 0, i32 4
  %42 = load i8*** %buffer, align 8
  %43 = load %struct.djpeg_dest_struct** %dest_mgr, align 8
  %buffer_height = getelementptr inbounds %struct.djpeg_dest_struct* %43, i32 0, i32 5
  %44 = load i32* %buffer_height, align 4
  %call53 = call i32 @jpeg_read_scanlines(%struct.jpeg_decompress_struct* %cinfo, i8** %42, i32 %44)
  store i32 %call53, i32* %num_scanlines, align 4
  %45 = load %struct.djpeg_dest_struct** %dest_mgr, align 8
  %put_pixel_rows = getelementptr inbounds %struct.djpeg_dest_struct* %45, i32 0, i32 1
  %46 = load void (%struct.jpeg_decompress_struct*, %struct.djpeg_dest_struct*, i32)** %put_pixel_rows, align 8
  %47 = load %struct.djpeg_dest_struct** %dest_mgr, align 8
  %48 = load i32* %num_scanlines, align 4
  call void %46(%struct.jpeg_decompress_struct* %cinfo, %struct.djpeg_dest_struct* %47, i32 %48)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %49 = load %struct.djpeg_dest_struct** %dest_mgr, align 8
  %finish_output = getelementptr inbounds %struct.djpeg_dest_struct* %49, i32 0, i32 2
  %50 = load void (%struct.jpeg_decompress_struct*, %struct.djpeg_dest_struct*)** %finish_output, align 8
  %51 = load %struct.djpeg_dest_struct** %dest_mgr, align 8
  call void %50(%struct.jpeg_decompress_struct* %cinfo, %struct.djpeg_dest_struct* %51)
  %call54 = call i32 @jpeg_finish_decompress(%struct.jpeg_decompress_struct* %cinfo)
  call void @jpeg_destroy_decompress(%struct.jpeg_decompress_struct* %cinfo)
  %52 = load %struct.__sFILE** %input_file, align 8
  %53 = load %struct.__sFILE** @__stdinp, align 8
  %cmp55 = icmp ne %struct.__sFILE* %52, %53
  br i1 %cmp55, label %if.then57, label %if.end59

if.then57:                                        ; preds = %while.end
  %54 = load %struct.__sFILE** %input_file, align 8
  %call58 = call i32 @fclose(%struct.__sFILE* %54)
  br label %if.end59

if.end59:                                         ; preds = %if.then57, %while.end
  %55 = load %struct.__sFILE** %output_file, align 8
  %56 = load %struct.__sFILE** @__stdoutp, align 8
  %cmp60 = icmp ne %struct.__sFILE* %55, %56
  br i1 %cmp60, label %if.then62, label %if.end64

if.then62:                                        ; preds = %if.end59
  %57 = load %struct.__sFILE** %output_file, align 8
  %call63 = call i32 @fclose(%struct.__sFILE* %57)
  br label %if.end64

if.end64:                                         ; preds = %if.then62, %if.end59
  %num_warnings = getelementptr inbounds %struct.jpeg_error_mgr* %jerr, i32 0, i32 8
  %58 = load i64* %num_warnings, align 8
  %tobool = icmp ne i64 %58, 0
  %cond = select i1 %tobool, i32 2, i32 0
  call void @exit(i32 %cond) #3
  unreachable

return:                                           ; No predecessors!
  %59 = load i32* %retval
  ret i32 %59
}

declare %struct.jpeg_error_mgr* @jpeg_std_error(%struct.jpeg_error_mgr*) #1

declare void @jpeg_CreateDecompress(%struct.jpeg_decompress_struct*, i32, i64) #1

declare void @jpeg_set_marker_processor(%struct.jpeg_decompress_struct*, i32, i32 (%struct.jpeg_decompress_struct*)*) #1

; Function Attrs: nounwind ssp uwtable
define internal i32 @COM_handler(%struct.jpeg_decompress_struct* %cinfo) #0 {
entry:
  %cinfo.addr = alloca %struct.jpeg_decompress_struct*, align 8
  %traceit = alloca i32, align 4
  %length = alloca i64, align 8
  %ch = alloca i32, align 4
  %lastch = alloca i32, align 4
  store %struct.jpeg_decompress_struct* %cinfo, %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %0 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %err = getelementptr inbounds %struct.jpeg_decompress_struct* %0, i32 0, i32 0
  %1 = load %struct.jpeg_error_mgr** %err, align 8
  %trace_level = getelementptr inbounds %struct.jpeg_error_mgr* %1, i32 0, i32 7
  %2 = load i32* %trace_level, align 4
  %cmp = icmp sge i32 %2, 1
  %conv = zext i1 %cmp to i32
  store i32 %conv, i32* %traceit, align 4
  store i32 0, i32* %lastch, align 4
  %3 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %call = call i32 @jpeg_getc(%struct.jpeg_decompress_struct* %3)
  %shl = shl i32 %call, 8
  %conv1 = zext i32 %shl to i64
  store i64 %conv1, i64* %length, align 8
  %4 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %call2 = call i32 @jpeg_getc(%struct.jpeg_decompress_struct* %4)
  %conv3 = zext i32 %call2 to i64
  %5 = load i64* %length, align 8
  %add = add nsw i64 %5, %conv3
  store i64 %add, i64* %length, align 8
  %6 = load i64* %length, align 8
  %sub = sub nsw i64 %6, 2
  store i64 %sub, i64* %length, align 8
  %7 = load i32* %traceit, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %8 = load %struct.__sFILE** @__stderrp, align 8
  %9 = load i64* %length, align 8
  %call4 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %8, i8* getelementptr inbounds ([22 x i8]* @.str67, i32 0, i32 0), i64 %9)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  br label %while.cond

while.cond:                                       ; preds = %if.end38, %if.end
  %10 = load i64* %length, align 8
  %dec = add nsw i64 %10, -1
  store i64 %dec, i64* %length, align 8
  %cmp5 = icmp sge i64 %dec, 0
  br i1 %cmp5, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %11 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %call7 = call i32 @jpeg_getc(%struct.jpeg_decompress_struct* %11)
  store i32 %call7, i32* %ch, align 4
  %12 = load i32* %traceit, align 4
  %tobool8 = icmp ne i32 %12, 0
  br i1 %tobool8, label %if.then9, label %if.end38

if.then9:                                         ; preds = %while.body
  %13 = load i32* %ch, align 4
  %cmp10 = icmp eq i32 %13, 13
  br i1 %cmp10, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.then9
  %14 = load %struct.__sFILE** @__stderrp, align 8
  %call13 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %14, i8* getelementptr inbounds ([2 x i8]* @.str68, i32 0, i32 0))
  br label %if.end37

if.else:                                          ; preds = %if.then9
  %15 = load i32* %ch, align 4
  %cmp14 = icmp eq i32 %15, 10
  br i1 %cmp14, label %if.then16, label %if.else22

if.then16:                                        ; preds = %if.else
  %16 = load i32* %lastch, align 4
  %cmp17 = icmp ne i32 %16, 13
  br i1 %cmp17, label %if.then19, label %if.end21

if.then19:                                        ; preds = %if.then16
  %17 = load %struct.__sFILE** @__stderrp, align 8
  %call20 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %17, i8* getelementptr inbounds ([2 x i8]* @.str68, i32 0, i32 0))
  br label %if.end21

if.end21:                                         ; preds = %if.then19, %if.then16
  br label %if.end36

if.else22:                                        ; preds = %if.else
  %18 = load i32* %ch, align 4
  %cmp23 = icmp eq i32 %18, 92
  br i1 %cmp23, label %if.then25, label %if.else27

if.then25:                                        ; preds = %if.else22
  %19 = load %struct.__sFILE** @__stderrp, align 8
  %call26 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %19, i8* getelementptr inbounds ([3 x i8]* @.str69, i32 0, i32 0))
  br label %if.end35

if.else27:                                        ; preds = %if.else22
  %20 = load i32* %ch, align 4
  %call28 = call i32 @isprint(i32 %20)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.then30, label %if.else32

if.then30:                                        ; preds = %if.else27
  %21 = load i32* %ch, align 4
  %22 = load %struct.__sFILE** @__stderrp, align 8
  %call31 = call i32 @putc(i32 %21, %struct.__sFILE* %22)
  br label %if.end34

if.else32:                                        ; preds = %if.else27
  %23 = load %struct.__sFILE** @__stderrp, align 8
  %24 = load i32* %ch, align 4
  %call33 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %23, i8* getelementptr inbounds ([6 x i8]* @.str70, i32 0, i32 0), i32 %24)
  br label %if.end34

if.end34:                                         ; preds = %if.else32, %if.then30
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.then25
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.end21
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.then12
  %25 = load i32* %ch, align 4
  store i32 %25, i32* %lastch, align 4
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %while.body
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %26 = load i32* %traceit, align 4
  %tobool39 = icmp ne i32 %26, 0
  br i1 %tobool39, label %if.then40, label %if.end42

if.then40:                                        ; preds = %while.end
  %27 = load %struct.__sFILE** @__stderrp, align 8
  %call41 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %27, i8* getelementptr inbounds ([2 x i8]* @.str68, i32 0, i32 0))
  br label %if.end42

if.end42:                                         ; preds = %if.then40, %while.end
  ret i32 1
}

; Function Attrs: nounwind ssp uwtable
define internal i32 @parse_switches(%struct.jpeg_decompress_struct* %cinfo, i32 %argc, i8** %argv, i32 %last_file_arg_seen, i32 %for_real) #0 {
entry:
  %cinfo.addr = alloca %struct.jpeg_decompress_struct*, align 8
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  %last_file_arg_seen.addr = alloca i32, align 4
  %for_real.addr = alloca i32, align 4
  %argn = alloca i32, align 4
  %arg = alloca i8*, align 8
  %val = alloca i32, align 4
  %mapfile = alloca %struct.__sFILE*, align 8
  %lval = alloca i64, align 8
  %ch = alloca i8, align 1
  store %struct.jpeg_decompress_struct* %cinfo, %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  store i32 %last_file_arg_seen, i32* %last_file_arg_seen.addr, align 4
  store i32 %for_real, i32* %for_real.addr, align 4
  store i32 3, i32* @requested_fmt, align 4
  store i8* null, i8** @outfilename, align 8
  %0 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %err = getelementptr inbounds %struct.jpeg_decompress_struct* %0, i32 0, i32 0
  %1 = load %struct.jpeg_error_mgr** %err, align 8
  %trace_level = getelementptr inbounds %struct.jpeg_error_mgr* %1, i32 0, i32 7
  store i32 0, i32* %trace_level, align 4
  store i32 1, i32* %argn, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32* %argn, align 4
  %3 = load i32* %argc.addr, align 4
  %cmp = icmp slt i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i32* %argn, align 4
  %idxprom = sext i32 %4 to i64
  %5 = load i8*** %argv.addr, align 8
  %arrayidx = getelementptr inbounds i8** %5, i64 %idxprom
  %6 = load i8** %arrayidx, align 8
  store i8* %6, i8** %arg, align 8
  %7 = load i8** %arg, align 8
  %8 = load i8* %7, align 1
  %conv = sext i8 %8 to i32
  %cmp1 = icmp ne i32 %conv, 45
  br i1 %cmp1, label %if.then, label %if.end6

if.then:                                          ; preds = %for.body
  %9 = load i32* %argn, align 4
  %10 = load i32* %last_file_arg_seen.addr, align 4
  %cmp3 = icmp sle i32 %9, %10
  br i1 %cmp3, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.then
  store i8* null, i8** @outfilename, align 8
  br label %for.inc

if.end:                                           ; preds = %if.then
  br label %for.end

if.end6:                                          ; preds = %for.body
  %11 = load i8** %arg, align 8
  %incdec.ptr = getelementptr inbounds i8* %11, i32 1
  store i8* %incdec.ptr, i8** %arg, align 8
  %12 = load i8** %arg, align 8
  %call = call i32 @keymatch(i8* %12, i8* getelementptr inbounds ([4 x i8]* @.str32, i32 0, i32 0), i32 1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then7, label %if.else

if.then7:                                         ; preds = %if.end6
  store i32 0, i32* @requested_fmt, align 4
  br label %if.end254

if.else:                                          ; preds = %if.end6
  %13 = load i8** %arg, align 8
  %call8 = call i32 @keymatch(i8* %13, i8* getelementptr inbounds ([7 x i8]* @.str33, i32 0, i32 0), i32 1)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.then18, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %14 = load i8** %arg, align 8
  %call10 = call i32 @keymatch(i8* %14, i8* getelementptr inbounds ([8 x i8]* @.str34, i32 0, i32 0), i32 1)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.then18, label %lor.lhs.false12

lor.lhs.false12:                                  ; preds = %lor.lhs.false
  %15 = load i8** %arg, align 8
  %call13 = call i32 @keymatch(i8* %15, i8* getelementptr inbounds ([9 x i8]* @.str35, i32 0, i32 0), i32 1)
  %tobool14 = icmp ne i32 %call13, 0
  br i1 %tobool14, label %if.then18, label %lor.lhs.false15

lor.lhs.false15:                                  ; preds = %lor.lhs.false12
  %16 = load i8** %arg, align 8
  %call16 = call i32 @keymatch(i8* %16, i8* getelementptr inbounds ([9 x i8]* @.str36, i32 0, i32 0), i32 1)
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %if.then18, label %if.else30

if.then18:                                        ; preds = %lor.lhs.false15, %lor.lhs.false12, %lor.lhs.false, %if.else
  %17 = load i32* %argn, align 4
  %inc = add nsw i32 %17, 1
  store i32 %inc, i32* %argn, align 4
  %18 = load i32* %argc.addr, align 4
  %cmp19 = icmp sge i32 %inc, %18
  br i1 %cmp19, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.then18
  call void @usage()
  br label %if.end22

if.end22:                                         ; preds = %if.then21, %if.then18
  %19 = load i32* %argn, align 4
  %idxprom23 = sext i32 %19 to i64
  %20 = load i8*** %argv.addr, align 8
  %arrayidx24 = getelementptr inbounds i8** %20, i64 %idxprom23
  %21 = load i8** %arrayidx24, align 8
  %call25 = call i32 (i8*, i8*, ...)* @sscanf(i8* %21, i8* getelementptr inbounds ([3 x i8]* @.str37, i32 0, i32 0), i32* %val)
  %cmp26 = icmp ne i32 %call25, 1
  br i1 %cmp26, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.end22
  call void @usage()
  br label %if.end29

if.end29:                                         ; preds = %if.then28, %if.end22
  %22 = load i32* %val, align 4
  %23 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %desired_number_of_colors = getelementptr inbounds %struct.jpeg_decompress_struct* %23, i32 0, i32 22
  store i32 %22, i32* %desired_number_of_colors, align 4
  %24 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %quantize_colors = getelementptr inbounds %struct.jpeg_decompress_struct* %24, i32 0, i32 19
  store i32 1, i32* %quantize_colors, align 4
  br label %if.end253

if.else30:                                        ; preds = %lor.lhs.false15
  %25 = load i8** %arg, align 8
  %call31 = call i32 @keymatch(i8* %25, i8* getelementptr inbounds ([4 x i8]* @.str38, i32 0, i32 0), i32 2)
  %tobool32 = icmp ne i32 %call31, 0
  br i1 %tobool32, label %if.then33, label %if.else62

if.then33:                                        ; preds = %if.else30
  %26 = load i32* %argn, align 4
  %inc34 = add nsw i32 %26, 1
  store i32 %inc34, i32* %argn, align 4
  %27 = load i32* %argc.addr, align 4
  %cmp35 = icmp sge i32 %inc34, %27
  br i1 %cmp35, label %if.then37, label %if.end38

if.then37:                                        ; preds = %if.then33
  call void @usage()
  br label %if.end38

if.end38:                                         ; preds = %if.then37, %if.then33
  %28 = load i32* %argn, align 4
  %idxprom39 = sext i32 %28 to i64
  %29 = load i8*** %argv.addr, align 8
  %arrayidx40 = getelementptr inbounds i8** %29, i64 %idxprom39
  %30 = load i8** %arrayidx40, align 8
  %call41 = call i32 @keymatch(i8* %30, i8* getelementptr inbounds ([4 x i8]* @.str39, i32 0, i32 0), i32 1)
  %tobool42 = icmp ne i32 %call41, 0
  br i1 %tobool42, label %if.then43, label %if.else44

if.then43:                                        ; preds = %if.end38
  %31 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %dct_method = getelementptr inbounds %struct.jpeg_decompress_struct* %31, i32 0, i32 16
  store i32 0, i32* %dct_method, align 4
  br label %if.end61

if.else44:                                        ; preds = %if.end38
  %32 = load i32* %argn, align 4
  %idxprom45 = sext i32 %32 to i64
  %33 = load i8*** %argv.addr, align 8
  %arrayidx46 = getelementptr inbounds i8** %33, i64 %idxprom45
  %34 = load i8** %arrayidx46, align 8
  %call47 = call i32 @keymatch(i8* %34, i8* getelementptr inbounds ([5 x i8]* @.str40, i32 0, i32 0), i32 2)
  %tobool48 = icmp ne i32 %call47, 0
  br i1 %tobool48, label %if.then49, label %if.else51

if.then49:                                        ; preds = %if.else44
  %35 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %dct_method50 = getelementptr inbounds %struct.jpeg_decompress_struct* %35, i32 0, i32 16
  store i32 1, i32* %dct_method50, align 4
  br label %if.end60

if.else51:                                        ; preds = %if.else44
  %36 = load i32* %argn, align 4
  %idxprom52 = sext i32 %36 to i64
  %37 = load i8*** %argv.addr, align 8
  %arrayidx53 = getelementptr inbounds i8** %37, i64 %idxprom52
  %38 = load i8** %arrayidx53, align 8
  %call54 = call i32 @keymatch(i8* %38, i8* getelementptr inbounds ([6 x i8]* @.str41, i32 0, i32 0), i32 2)
  %tobool55 = icmp ne i32 %call54, 0
  br i1 %tobool55, label %if.then56, label %if.else58

if.then56:                                        ; preds = %if.else51
  %39 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %dct_method57 = getelementptr inbounds %struct.jpeg_decompress_struct* %39, i32 0, i32 16
  store i32 2, i32* %dct_method57, align 4
  br label %if.end59

if.else58:                                        ; preds = %if.else51
  call void @usage()
  br label %if.end59

if.end59:                                         ; preds = %if.else58, %if.then56
  br label %if.end60

if.end60:                                         ; preds = %if.end59, %if.then49
  br label %if.end61

if.end61:                                         ; preds = %if.end60, %if.then43
  br label %if.end252

if.else62:                                        ; preds = %if.else30
  %40 = load i8** %arg, align 8
  %call63 = call i32 @keymatch(i8* %40, i8* getelementptr inbounds ([7 x i8]* @.str42, i32 0, i32 0), i32 2)
  %tobool64 = icmp ne i32 %call63, 0
  br i1 %tobool64, label %if.then65, label %if.else94

if.then65:                                        ; preds = %if.else62
  %41 = load i32* %argn, align 4
  %inc66 = add nsw i32 %41, 1
  store i32 %inc66, i32* %argn, align 4
  %42 = load i32* %argc.addr, align 4
  %cmp67 = icmp sge i32 %inc66, %42
  br i1 %cmp67, label %if.then69, label %if.end70

if.then69:                                        ; preds = %if.then65
  call void @usage()
  br label %if.end70

if.end70:                                         ; preds = %if.then69, %if.then65
  %43 = load i32* %argn, align 4
  %idxprom71 = sext i32 %43 to i64
  %44 = load i8*** %argv.addr, align 8
  %arrayidx72 = getelementptr inbounds i8** %44, i64 %idxprom71
  %45 = load i8** %arrayidx72, align 8
  %call73 = call i32 @keymatch(i8* %45, i8* getelementptr inbounds ([3 x i8]* @.str43, i32 0, i32 0), i32 2)
  %tobool74 = icmp ne i32 %call73, 0
  br i1 %tobool74, label %if.then75, label %if.else76

if.then75:                                        ; preds = %if.end70
  %46 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %dither_mode = getelementptr inbounds %struct.jpeg_decompress_struct* %46, i32 0, i32 20
  store i32 2, i32* %dither_mode, align 4
  br label %if.end93

if.else76:                                        ; preds = %if.end70
  %47 = load i32* %argn, align 4
  %idxprom77 = sext i32 %47 to i64
  %48 = load i8*** %argv.addr, align 8
  %arrayidx78 = getelementptr inbounds i8** %48, i64 %idxprom77
  %49 = load i8** %arrayidx78, align 8
  %call79 = call i32 @keymatch(i8* %49, i8* getelementptr inbounds ([5 x i8]* @.str44, i32 0, i32 0), i32 2)
  %tobool80 = icmp ne i32 %call79, 0
  br i1 %tobool80, label %if.then81, label %if.else83

if.then81:                                        ; preds = %if.else76
  %50 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %dither_mode82 = getelementptr inbounds %struct.jpeg_decompress_struct* %50, i32 0, i32 20
  store i32 0, i32* %dither_mode82, align 4
  br label %if.end92

if.else83:                                        ; preds = %if.else76
  %51 = load i32* %argn, align 4
  %idxprom84 = sext i32 %51 to i64
  %52 = load i8*** %argv.addr, align 8
  %arrayidx85 = getelementptr inbounds i8** %52, i64 %idxprom84
  %53 = load i8** %arrayidx85, align 8
  %call86 = call i32 @keymatch(i8* %53, i8* getelementptr inbounds ([8 x i8]* @.str45, i32 0, i32 0), i32 2)
  %tobool87 = icmp ne i32 %call86, 0
  br i1 %tobool87, label %if.then88, label %if.else90

if.then88:                                        ; preds = %if.else83
  %54 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %dither_mode89 = getelementptr inbounds %struct.jpeg_decompress_struct* %54, i32 0, i32 20
  store i32 1, i32* %dither_mode89, align 4
  br label %if.end91

if.else90:                                        ; preds = %if.else83
  call void @usage()
  br label %if.end91

if.end91:                                         ; preds = %if.else90, %if.then88
  br label %if.end92

if.end92:                                         ; preds = %if.end91, %if.then81
  br label %if.end93

if.end93:                                         ; preds = %if.end92, %if.then75
  br label %if.end251

if.else94:                                        ; preds = %if.else62
  %55 = load i8** %arg, align 8
  %call95 = call i32 @keymatch(i8* %55, i8* getelementptr inbounds ([6 x i8]* @.str46, i32 0, i32 0), i32 1)
  %tobool96 = icmp ne i32 %call95, 0
  br i1 %tobool96, label %if.then100, label %lor.lhs.false97

lor.lhs.false97:                                  ; preds = %if.else94
  %56 = load i8** %arg, align 8
  %call98 = call i32 @keymatch(i8* %56, i8* getelementptr inbounds ([8 x i8]* @.str47, i32 0, i32 0), i32 1)
  %tobool99 = icmp ne i32 %call98, 0
  br i1 %tobool99, label %if.then100, label %if.else108

if.then100:                                       ; preds = %lor.lhs.false97, %if.else94
  %57 = load i32* @parse_switches.printed_version, align 4
  %tobool101 = icmp ne i32 %57, 0
  br i1 %tobool101, label %if.end104, label %if.then102

if.then102:                                       ; preds = %if.then100
  %58 = load %struct.__sFILE** @__stderrp, align 8
  %call103 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %58, i8* getelementptr inbounds ([47 x i8]* @.str48, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8]* @.str49, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8]* @.str50, i32 0, i32 0))
  store i32 1, i32* @parse_switches.printed_version, align 4
  br label %if.end104

if.end104:                                        ; preds = %if.then102, %if.then100
  %59 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %err105 = getelementptr inbounds %struct.jpeg_decompress_struct* %59, i32 0, i32 0
  %60 = load %struct.jpeg_error_mgr** %err105, align 8
  %trace_level106 = getelementptr inbounds %struct.jpeg_error_mgr* %60, i32 0, i32 7
  %61 = load i32* %trace_level106, align 4
  %inc107 = add nsw i32 %61, 1
  store i32 %inc107, i32* %trace_level106, align 4
  br label %if.end250

if.else108:                                       ; preds = %lor.lhs.false97
  %62 = load i8** %arg, align 8
  %call109 = call i32 @keymatch(i8* %62, i8* getelementptr inbounds ([5 x i8]* @.str40, i32 0, i32 0), i32 1)
  %tobool110 = icmp ne i32 %call109, 0
  br i1 %tobool110, label %if.then111, label %if.else119

if.then111:                                       ; preds = %if.else108
  %63 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %two_pass_quantize = getelementptr inbounds %struct.jpeg_decompress_struct* %63, i32 0, i32 21
  store i32 0, i32* %two_pass_quantize, align 4
  %64 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %dither_mode112 = getelementptr inbounds %struct.jpeg_decompress_struct* %64, i32 0, i32 20
  store i32 1, i32* %dither_mode112, align 4
  %65 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %quantize_colors113 = getelementptr inbounds %struct.jpeg_decompress_struct* %65, i32 0, i32 19
  %66 = load i32* %quantize_colors113, align 4
  %tobool114 = icmp ne i32 %66, 0
  br i1 %tobool114, label %if.end117, label %if.then115

if.then115:                                       ; preds = %if.then111
  %67 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %desired_number_of_colors116 = getelementptr inbounds %struct.jpeg_decompress_struct* %67, i32 0, i32 22
  store i32 216, i32* %desired_number_of_colors116, align 4
  br label %if.end117

if.end117:                                        ; preds = %if.then115, %if.then111
  %68 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %dct_method118 = getelementptr inbounds %struct.jpeg_decompress_struct* %68, i32 0, i32 16
  store i32 1, i32* %dct_method118, align 4
  %69 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %do_fancy_upsampling = getelementptr inbounds %struct.jpeg_decompress_struct* %69, i32 0, i32 17
  store i32 0, i32* %do_fancy_upsampling, align 4
  br label %if.end249

if.else119:                                       ; preds = %if.else108
  %70 = load i8** %arg, align 8
  %call120 = call i32 @keymatch(i8* %70, i8* getelementptr inbounds ([4 x i8]* @.str51, i32 0, i32 0), i32 1)
  %tobool121 = icmp ne i32 %call120, 0
  br i1 %tobool121, label %if.then122, label %if.else123

if.then122:                                       ; preds = %if.else119
  store i32 1, i32* @requested_fmt, align 4
  br label %if.end248

if.else123:                                       ; preds = %if.else119
  %71 = load i8** %arg, align 8
  %call124 = call i32 @keymatch(i8* %71, i8* getelementptr inbounds ([10 x i8]* @.str52, i32 0, i32 0), i32 2)
  %tobool125 = icmp ne i32 %call124, 0
  br i1 %tobool125, label %if.then129, label %lor.lhs.false126

lor.lhs.false126:                                 ; preds = %if.else123
  %72 = load i8** %arg, align 8
  %call127 = call i32 @keymatch(i8* %72, i8* getelementptr inbounds ([10 x i8]* @.str53, i32 0, i32 0), i32 2)
  %tobool128 = icmp ne i32 %call127, 0
  br i1 %tobool128, label %if.then129, label %if.else130

if.then129:                                       ; preds = %lor.lhs.false126, %if.else123
  %73 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %out_color_space = getelementptr inbounds %struct.jpeg_decompress_struct* %73, i32 0, i32 10
  store i32 1, i32* %out_color_space, align 4
  br label %if.end247

if.else130:                                       ; preds = %lor.lhs.false126
  %74 = load i8** %arg, align 8
  %call131 = call i32 @keymatch(i8* %74, i8* getelementptr inbounds ([4 x i8]* @.str54, i32 0, i32 0), i32 3)
  %tobool132 = icmp ne i32 %call131, 0
  br i1 %tobool132, label %if.then133, label %if.else154

if.then133:                                       ; preds = %if.else130
  %75 = load i32* %argn, align 4
  %inc134 = add nsw i32 %75, 1
  store i32 %inc134, i32* %argn, align 4
  %76 = load i32* %argc.addr, align 4
  %cmp135 = icmp sge i32 %inc134, %76
  br i1 %cmp135, label %if.then137, label %if.end138

if.then137:                                       ; preds = %if.then133
  call void @usage()
  br label %if.end138

if.end138:                                        ; preds = %if.then137, %if.then133
  %77 = load i32* %for_real.addr, align 4
  %tobool139 = icmp ne i32 %77, 0
  br i1 %tobool139, label %if.then140, label %if.end153

if.then140:                                       ; preds = %if.end138
  %78 = load i32* %argn, align 4
  %idxprom141 = sext i32 %78 to i64
  %79 = load i8*** %argv.addr, align 8
  %arrayidx142 = getelementptr inbounds i8** %79, i64 %idxprom141
  %80 = load i8** %arrayidx142, align 8
  %call143 = call %struct.__sFILE* @"\01_fopen"(i8* %80, i8* getelementptr inbounds ([3 x i8]* @.str2, i32 0, i32 0))
  store %struct.__sFILE* %call143, %struct.__sFILE** %mapfile, align 8
  %cmp144 = icmp eq %struct.__sFILE* %call143, null
  br i1 %cmp144, label %if.then146, label %if.end150

if.then146:                                       ; preds = %if.then140
  %81 = load %struct.__sFILE** @__stderrp, align 8
  %82 = load i8** @progname, align 8
  %83 = load i32* %argn, align 4
  %idxprom147 = sext i32 %83 to i64
  %84 = load i8*** %argv.addr, align 8
  %arrayidx148 = getelementptr inbounds i8** %84, i64 %idxprom147
  %85 = load i8** %arrayidx148, align 8
  %call149 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %81, i8* getelementptr inbounds ([19 x i8]* @.str3, i32 0, i32 0), i8* %82, i8* %85)
  call void @exit(i32 1) #3
  unreachable

if.end150:                                        ; preds = %if.then140
  %86 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %87 = load %struct.__sFILE** %mapfile, align 8
  call void @read_color_map(%struct.jpeg_decompress_struct* %86, %struct.__sFILE* %87)
  %88 = load %struct.__sFILE** %mapfile, align 8
  %call151 = call i32 @fclose(%struct.__sFILE* %88)
  %89 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %quantize_colors152 = getelementptr inbounds %struct.jpeg_decompress_struct* %89, i32 0, i32 19
  store i32 1, i32* %quantize_colors152, align 4
  br label %if.end153

if.end153:                                        ; preds = %if.end150, %if.end138
  br label %if.end246

if.else154:                                       ; preds = %if.else130
  %90 = load i8** %arg, align 8
  %call155 = call i32 @keymatch(i8* %90, i8* getelementptr inbounds ([10 x i8]* @.str55, i32 0, i32 0), i32 3)
  %tobool156 = icmp ne i32 %call155, 0
  br i1 %tobool156, label %if.then157, label %if.else180

if.then157:                                       ; preds = %if.else154
  store i8 120, i8* %ch, align 1
  %91 = load i32* %argn, align 4
  %inc158 = add nsw i32 %91, 1
  store i32 %inc158, i32* %argn, align 4
  %92 = load i32* %argc.addr, align 4
  %cmp159 = icmp sge i32 %inc158, %92
  br i1 %cmp159, label %if.then161, label %if.end162

if.then161:                                       ; preds = %if.then157
  call void @usage()
  br label %if.end162

if.end162:                                        ; preds = %if.then161, %if.then157
  %93 = load i32* %argn, align 4
  %idxprom163 = sext i32 %93 to i64
  %94 = load i8*** %argv.addr, align 8
  %arrayidx164 = getelementptr inbounds i8** %94, i64 %idxprom163
  %95 = load i8** %arrayidx164, align 8
  %call165 = call i32 (i8*, i8*, ...)* @sscanf(i8* %95, i8* getelementptr inbounds ([6 x i8]* @.str56, i32 0, i32 0), i64* %lval, i8* %ch)
  %cmp166 = icmp slt i32 %call165, 1
  br i1 %cmp166, label %if.then168, label %if.end169

if.then168:                                       ; preds = %if.end162
  call void @usage()
  br label %if.end169

if.end169:                                        ; preds = %if.then168, %if.end162
  %96 = load i8* %ch, align 1
  %conv170 = sext i8 %96 to i32
  %cmp171 = icmp eq i32 %conv170, 109
  br i1 %cmp171, label %if.then177, label %lor.lhs.false173

lor.lhs.false173:                                 ; preds = %if.end169
  %97 = load i8* %ch, align 1
  %conv174 = sext i8 %97 to i32
  %cmp175 = icmp eq i32 %conv174, 77
  br i1 %cmp175, label %if.then177, label %if.end178

if.then177:                                       ; preds = %lor.lhs.false173, %if.end169
  %98 = load i64* %lval, align 8
  %mul = mul nsw i64 %98, 1000
  store i64 %mul, i64* %lval, align 8
  br label %if.end178

if.end178:                                        ; preds = %if.then177, %lor.lhs.false173
  %99 = load i64* %lval, align 8
  %mul179 = mul nsw i64 %99, 1000
  %100 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %mem = getelementptr inbounds %struct.jpeg_decompress_struct* %100, i32 0, i32 1
  %101 = load %struct.jpeg_memory_mgr** %mem, align 8
  %max_memory_to_use = getelementptr inbounds %struct.jpeg_memory_mgr* %101, i32 0, i32 11
  store i64 %mul179, i64* %max_memory_to_use, align 8
  br label %if.end245

if.else180:                                       ; preds = %if.else154
  %102 = load i8** %arg, align 8
  %call181 = call i32 @keymatch(i8* %102, i8* getelementptr inbounds ([9 x i8]* @.str57, i32 0, i32 0), i32 3)
  %tobool182 = icmp ne i32 %call181, 0
  br i1 %tobool182, label %if.then183, label %if.else185

if.then183:                                       ; preds = %if.else180
  %103 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %do_fancy_upsampling184 = getelementptr inbounds %struct.jpeg_decompress_struct* %103, i32 0, i32 17
  store i32 0, i32* %do_fancy_upsampling184, align 4
  br label %if.end244

if.else185:                                       ; preds = %if.else180
  %104 = load i8** %arg, align 8
  %call186 = call i32 @keymatch(i8* %104, i8* getelementptr inbounds ([8 x i8]* @.str58, i32 0, i32 0), i32 3)
  %tobool187 = icmp ne i32 %call186, 0
  br i1 %tobool187, label %if.then188, label %if.else190

if.then188:                                       ; preds = %if.else185
  %105 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %two_pass_quantize189 = getelementptr inbounds %struct.jpeg_decompress_struct* %105, i32 0, i32 21
  store i32 0, i32* %two_pass_quantize189, align 4
  br label %if.end243

if.else190:                                       ; preds = %if.else185
  %106 = load i8** %arg, align 8
  %call191 = call i32 @keymatch(i8* %106, i8* getelementptr inbounds ([4 x i8]* @.str59, i32 0, i32 0), i32 3)
  %tobool192 = icmp ne i32 %call191, 0
  br i1 %tobool192, label %if.then193, label %if.else194

if.then193:                                       ; preds = %if.else190
  store i32 2, i32* @requested_fmt, align 4
  br label %if.end242

if.else194:                                       ; preds = %if.else190
  %107 = load i8** %arg, align 8
  %call195 = call i32 @keymatch(i8* %107, i8* getelementptr inbounds ([8 x i8]* @.str60, i32 0, i32 0), i32 4)
  %tobool196 = icmp ne i32 %call195, 0
  br i1 %tobool196, label %if.then197, label %if.else205

if.then197:                                       ; preds = %if.else194
  %108 = load i32* %argn, align 4
  %inc198 = add nsw i32 %108, 1
  store i32 %inc198, i32* %argn, align 4
  %109 = load i32* %argc.addr, align 4
  %cmp199 = icmp sge i32 %inc198, %109
  br i1 %cmp199, label %if.then201, label %if.end202

if.then201:                                       ; preds = %if.then197
  call void @usage()
  br label %if.end202

if.end202:                                        ; preds = %if.then201, %if.then197
  %110 = load i32* %argn, align 4
  %idxprom203 = sext i32 %110 to i64
  %111 = load i8*** %argv.addr, align 8
  %arrayidx204 = getelementptr inbounds i8** %111, i64 %idxprom203
  %112 = load i8** %arrayidx204, align 8
  store i8* %112, i8** @outfilename, align 8
  br label %if.end241

if.else205:                                       ; preds = %if.else194
  %113 = load i8** %arg, align 8
  %call206 = call i32 @keymatch(i8* %113, i8* getelementptr inbounds ([4 x i8]* @.str61, i32 0, i32 0), i32 1)
  %tobool207 = icmp ne i32 %call206, 0
  br i1 %tobool207, label %if.then211, label %lor.lhs.false208

lor.lhs.false208:                                 ; preds = %if.else205
  %114 = load i8** %arg, align 8
  %call209 = call i32 @keymatch(i8* %114, i8* getelementptr inbounds ([4 x i8]* @.str62, i32 0, i32 0), i32 1)
  %tobool210 = icmp ne i32 %call209, 0
  br i1 %tobool210, label %if.then211, label %if.else212

if.then211:                                       ; preds = %lor.lhs.false208, %if.else205
  store i32 3, i32* @requested_fmt, align 4
  br label %if.end240

if.else212:                                       ; preds = %lor.lhs.false208
  %115 = load i8** %arg, align 8
  %call213 = call i32 @keymatch(i8* %115, i8* getelementptr inbounds ([4 x i8]* @.str63, i32 0, i32 0), i32 1)
  %tobool214 = icmp ne i32 %call213, 0
  br i1 %tobool214, label %if.then215, label %if.else216

if.then215:                                       ; preds = %if.else212
  store i32 4, i32* @requested_fmt, align 4
  br label %if.end239

if.else216:                                       ; preds = %if.else212
  %116 = load i8** %arg, align 8
  %call217 = call i32 @keymatch(i8* %116, i8* getelementptr inbounds ([6 x i8]* @.str64, i32 0, i32 0), i32 1)
  %tobool218 = icmp ne i32 %call217, 0
  br i1 %tobool218, label %if.then219, label %if.else232

if.then219:                                       ; preds = %if.else216
  %117 = load i32* %argn, align 4
  %inc220 = add nsw i32 %117, 1
  store i32 %inc220, i32* %argn, align 4
  %118 = load i32* %argc.addr, align 4
  %cmp221 = icmp sge i32 %inc220, %118
  br i1 %cmp221, label %if.then223, label %if.end224

if.then223:                                       ; preds = %if.then219
  call void @usage()
  br label %if.end224

if.end224:                                        ; preds = %if.then223, %if.then219
  %119 = load i32* %argn, align 4
  %idxprom225 = sext i32 %119 to i64
  %120 = load i8*** %argv.addr, align 8
  %arrayidx226 = getelementptr inbounds i8** %120, i64 %idxprom225
  %121 = load i8** %arrayidx226, align 8
  %122 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %scale_num = getelementptr inbounds %struct.jpeg_decompress_struct* %122, i32 0, i32 11
  %123 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %scale_denom = getelementptr inbounds %struct.jpeg_decompress_struct* %123, i32 0, i32 12
  %call227 = call i32 (i8*, i8*, ...)* @sscanf(i8* %121, i8* getelementptr inbounds ([6 x i8]* @.str65, i32 0, i32 0), i32* %scale_num, i32* %scale_denom)
  %cmp228 = icmp ne i32 %call227, 2
  br i1 %cmp228, label %if.then230, label %if.end231

if.then230:                                       ; preds = %if.end224
  call void @usage()
  br label %if.end231

if.end231:                                        ; preds = %if.then230, %if.end224
  br label %if.end238

if.else232:                                       ; preds = %if.else216
  %124 = load i8** %arg, align 8
  %call233 = call i32 @keymatch(i8* %124, i8* getelementptr inbounds ([6 x i8]* @.str66, i32 0, i32 0), i32 1)
  %tobool234 = icmp ne i32 %call233, 0
  br i1 %tobool234, label %if.then235, label %if.else236

if.then235:                                       ; preds = %if.else232
  store i32 5, i32* @requested_fmt, align 4
  br label %if.end237

if.else236:                                       ; preds = %if.else232
  call void @usage()
  br label %if.end237

if.end237:                                        ; preds = %if.else236, %if.then235
  br label %if.end238

if.end238:                                        ; preds = %if.end237, %if.end231
  br label %if.end239

if.end239:                                        ; preds = %if.end238, %if.then215
  br label %if.end240

if.end240:                                        ; preds = %if.end239, %if.then211
  br label %if.end241

if.end241:                                        ; preds = %if.end240, %if.end202
  br label %if.end242

if.end242:                                        ; preds = %if.end241, %if.then193
  br label %if.end243

if.end243:                                        ; preds = %if.end242, %if.then188
  br label %if.end244

if.end244:                                        ; preds = %if.end243, %if.then183
  br label %if.end245

if.end245:                                        ; preds = %if.end244, %if.end178
  br label %if.end246

if.end246:                                        ; preds = %if.end245, %if.end153
  br label %if.end247

if.end247:                                        ; preds = %if.end246, %if.then129
  br label %if.end248

if.end248:                                        ; preds = %if.end247, %if.then122
  br label %if.end249

if.end249:                                        ; preds = %if.end248, %if.end117
  br label %if.end250

if.end250:                                        ; preds = %if.end249, %if.end104
  br label %if.end251

if.end251:                                        ; preds = %if.end250, %if.end93
  br label %if.end252

if.end252:                                        ; preds = %if.end251, %if.end61
  br label %if.end253

if.end253:                                        ; preds = %if.end252, %if.end29
  br label %if.end254

if.end254:                                        ; preds = %if.end253, %if.then7
  br label %for.inc

for.inc:                                          ; preds = %if.end254, %if.then5
  %125 = load i32* %argn, align 4
  %inc255 = add nsw i32 %125, 1
  store i32 %inc255, i32* %argn, align 4
  br label %for.cond

for.end:                                          ; preds = %if.end, %for.cond
  %126 = load i32* %argn, align 4
  ret i32 %126
}

declare i32 @fprintf(%struct.__sFILE*, i8*, ...) #1

; Function Attrs: nounwind ssp uwtable
define internal void @usage() #0 {
entry:
  %0 = load %struct.__sFILE** @__stderrp, align 8
  %1 = load i8** @progname, align 8
  %call = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %0, i8* getelementptr inbounds ([22 x i8]* @.str5, i32 0, i32 0), i8* %1)
  %2 = load %struct.__sFILE** @__stderrp, align 8
  %call1 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %2, i8* getelementptr inbounds ([13 x i8]* @.str6, i32 0, i32 0))
  %3 = load %struct.__sFILE** @__stderrp, align 8
  %call2 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %3, i8* getelementptr inbounds ([38 x i8]* @.str7, i32 0, i32 0))
  %4 = load %struct.__sFILE** @__stderrp, align 8
  %call3 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %4, i8* getelementptr inbounds ([56 x i8]* @.str8, i32 0, i32 0))
  %5 = load %struct.__sFILE** @__stderrp, align 8
  %call4 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %5, i8* getelementptr inbounds ([47 x i8]* @.str9, i32 0, i32 0))
  %6 = load %struct.__sFILE** @__stderrp, align 8
  %call5 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %6, i8* getelementptr inbounds ([41 x i8]* @.str10, i32 0, i32 0))
  %7 = load %struct.__sFILE** @__stderrp, align 8
  %call6 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %7, i8* getelementptr inbounds ([62 x i8]* @.str11, i32 0, i32 0))
  %8 = load %struct.__sFILE** @__stderrp, align 8
  %call7 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %8, i8* getelementptr inbounds ([61 x i8]* @.str12, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8]* @.str13, i32 0, i32 0))
  %9 = load %struct.__sFILE** @__stderrp, align 8
  %call8 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %9, i8* getelementptr inbounds ([45 x i8]* @.str14, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8]* @.str13, i32 0, i32 0))
  %10 = load %struct.__sFILE** @__stderrp, align 8
  %call9 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %10, i8* getelementptr inbounds ([58 x i8]* @.str15, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8]* @.str13, i32 0, i32 0))
  %11 = load %struct.__sFILE** @__stderrp, align 8
  %call10 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %11, i8* getelementptr inbounds ([59 x i8]* @.str16, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8]* @.str17, i32 0, i32 0))
  %12 = load %struct.__sFILE** @__stderrp, align 8
  %call11 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %12, i8* getelementptr inbounds ([47 x i8]* @.str18, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8]* @.str13, i32 0, i32 0))
  %13 = load %struct.__sFILE** @__stderrp, align 8
  %call12 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %13, i8* getelementptr inbounds ([30 x i8]* @.str19, i32 0, i32 0))
  %14 = load %struct.__sFILE** @__stderrp, align 8
  %call13 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %14, i8* getelementptr inbounds ([43 x i8]* @.str20, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8]* @.str17, i32 0, i32 0))
  %15 = load %struct.__sFILE** @__stderrp, align 8
  %call14 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %15, i8* getelementptr inbounds ([57 x i8]* @.str21, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8]* @.str13, i32 0, i32 0))
  %16 = load %struct.__sFILE** @__stderrp, align 8
  %call15 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %16, i8* getelementptr inbounds ([50 x i8]* @.str22, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8]* @.str13, i32 0, i32 0))
  %17 = load %struct.__sFILE** @__stderrp, align 8
  %call16 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %17, i8* getelementptr inbounds ([46 x i8]* @.str23, i32 0, i32 0))
  %18 = load %struct.__sFILE** @__stderrp, align 8
  %call17 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %18, i8* getelementptr inbounds ([54 x i8]* @.str24, i32 0, i32 0))
  %19 = load %struct.__sFILE** @__stderrp, align 8
  %call18 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %19, i8* getelementptr inbounds ([63 x i8]* @.str25, i32 0, i32 0))
  %20 = load %struct.__sFILE** @__stderrp, align 8
  %call19 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %20, i8* getelementptr inbounds ([57 x i8]* @.str26, i32 0, i32 0))
  %21 = load %struct.__sFILE** @__stderrp, align 8
  %call20 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %21, i8* getelementptr inbounds ([52 x i8]* @.str27, i32 0, i32 0))
  %22 = load %struct.__sFILE** @__stderrp, align 8
  %call21 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %22, i8* getelementptr inbounds ([62 x i8]* @.str28, i32 0, i32 0))
  %23 = load %struct.__sFILE** @__stderrp, align 8
  %call22 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %23, i8* getelementptr inbounds ([52 x i8]* @.str29, i32 0, i32 0))
  %24 = load %struct.__sFILE** @__stderrp, align 8
  %call23 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %24, i8* getelementptr inbounds ([47 x i8]* @.str30, i32 0, i32 0))
  %25 = load %struct.__sFILE** @__stderrp, align 8
  %call24 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %25, i8* getelementptr inbounds ([44 x i8]* @.str31, i32 0, i32 0))
  call void @exit(i32 1) #3
  unreachable

return:                                           ; No predecessors!
  ret void
}

declare %struct.__sFILE* @"\01_fopen"(i8*, i8*) #1

; Function Attrs: noreturn
declare void @exit(i32) #2

declare %struct.__sFILE* @read_stdin() #1

declare %struct.__sFILE* @write_stdout() #1

declare void @jpeg_stdio_src(%struct.jpeg_decompress_struct*, %struct.__sFILE*) #1

declare i32 @jpeg_read_header(%struct.jpeg_decompress_struct*, i32) #1

declare %struct.djpeg_dest_struct* @jinit_write_bmp(%struct.jpeg_decompress_struct*, i32) #1

declare %struct.djpeg_dest_struct* @jinit_write_gif(%struct.jpeg_decompress_struct*) #1

declare %struct.djpeg_dest_struct* @jinit_write_ppm(%struct.jpeg_decompress_struct*) #1

declare %struct.djpeg_dest_struct* @jinit_write_targa(%struct.jpeg_decompress_struct*) #1

declare i32 @jpeg_start_decompress(%struct.jpeg_decompress_struct*) #1

declare i32 @jpeg_read_scanlines(%struct.jpeg_decompress_struct*, i8**, i32) #1

declare i32 @jpeg_finish_decompress(%struct.jpeg_decompress_struct*) #1

declare void @jpeg_destroy_decompress(%struct.jpeg_decompress_struct*) #1

declare i32 @fclose(%struct.__sFILE*) #1

declare i32 @keymatch(i8*, i8*, i32) #1

declare i32 @sscanf(i8*, i8*, ...) #1

declare void @read_color_map(%struct.jpeg_decompress_struct*, %struct.__sFILE*) #1

; Function Attrs: nounwind ssp uwtable
define internal i32 @jpeg_getc(%struct.jpeg_decompress_struct* %cinfo) #0 {
entry:
  %cinfo.addr = alloca %struct.jpeg_decompress_struct*, align 8
  %datasrc = alloca %struct.jpeg_source_mgr*, align 8
  store %struct.jpeg_decompress_struct* %cinfo, %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %0 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %src = getelementptr inbounds %struct.jpeg_decompress_struct* %0, i32 0, i32 5
  %1 = load %struct.jpeg_source_mgr** %src, align 8
  store %struct.jpeg_source_mgr* %1, %struct.jpeg_source_mgr** %datasrc, align 8
  %2 = load %struct.jpeg_source_mgr** %datasrc, align 8
  %bytes_in_buffer = getelementptr inbounds %struct.jpeg_source_mgr* %2, i32 0, i32 1
  %3 = load i64* %bytes_in_buffer, align 8
  %cmp = icmp eq i64 %3, 0
  br i1 %cmp, label %if.then, label %if.end3

if.then:                                          ; preds = %entry
  %4 = load %struct.jpeg_source_mgr** %datasrc, align 8
  %fill_input_buffer = getelementptr inbounds %struct.jpeg_source_mgr* %4, i32 0, i32 3
  %5 = load i32 (%struct.jpeg_decompress_struct*)** %fill_input_buffer, align 8
  %6 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %call = call i32 %5(%struct.jpeg_decompress_struct* %6)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then1

if.then1:                                         ; preds = %if.then
  %7 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %err = getelementptr inbounds %struct.jpeg_decompress_struct* %7, i32 0, i32 0
  %8 = load %struct.jpeg_error_mgr** %err, align 8
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr* %8, i32 0, i32 5
  store i32 22, i32* %msg_code, align 4
  %9 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %err2 = getelementptr inbounds %struct.jpeg_decompress_struct* %9, i32 0, i32 0
  %10 = load %struct.jpeg_error_mgr** %err2, align 8
  %error_exit = getelementptr inbounds %struct.jpeg_error_mgr* %10, i32 0, i32 0
  %11 = load void (%struct.jpeg_common_struct*)** %error_exit, align 8
  %12 = load %struct.jpeg_decompress_struct** %cinfo.addr, align 8
  %13 = bitcast %struct.jpeg_decompress_struct* %12 to %struct.jpeg_common_struct*
  call void %11(%struct.jpeg_common_struct* %13)
  br label %if.end

if.end:                                           ; preds = %if.then1, %if.then
  br label %if.end3

if.end3:                                          ; preds = %if.end, %entry
  %14 = load %struct.jpeg_source_mgr** %datasrc, align 8
  %bytes_in_buffer4 = getelementptr inbounds %struct.jpeg_source_mgr* %14, i32 0, i32 1
  %15 = load i64* %bytes_in_buffer4, align 8
  %dec = add i64 %15, -1
  store i64 %dec, i64* %bytes_in_buffer4, align 8
  %16 = load %struct.jpeg_source_mgr** %datasrc, align 8
  %next_input_byte = getelementptr inbounds %struct.jpeg_source_mgr* %16, i32 0, i32 0
  %17 = load i8** %next_input_byte, align 8
  %incdec.ptr = getelementptr inbounds i8* %17, i32 1
  store i8* %incdec.ptr, i8** %next_input_byte, align 8
  %18 = load i8* %17, align 1
  %conv = zext i8 %18 to i32
  ret i32 %conv
}

declare i32 @isprint(i32) #1

declare i32 @putc(i32, %struct.__sFILE*) #1

attributes #0 = { nounwind ssp uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { noreturn }
