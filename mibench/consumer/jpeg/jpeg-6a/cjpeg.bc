; ModuleID = 'cjpeg.c'
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-apple-macosx10.9.0"

%struct.__sFILE = type { i8*, i32, i32, i16, i16, %struct.__sbuf, i32, i8*, i32 (i8*)*, i32 (i8*, i8*, i32)*, i64 (i8*, i64, i32)*, i32 (i8*, i8*, i32)*, %struct.__sbuf, %struct.__sFILEX*, i32, [3 x i8], [1 x i8], %struct.__sbuf, i32, i64 }
%struct.__sbuf = type { i8*, i32 }
%struct.__sFILEX = type opaque
%struct.jpeg_compress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_destination_mgr*, i32, i32, i32, i32, double, i32, i32, i32, %struct.jpeg_component_info*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], [16 x i8], [16 x i8], [16 x i8], i32, %struct.jpeg_scan_info*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, i16, i16, i32, i32, i32, i32, i32, i32, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, %struct.jpeg_comp_master*, %struct.jpeg_c_main_controller*, %struct.jpeg_c_prep_controller*, %struct.jpeg_c_coef_controller*, %struct.jpeg_marker_writer*, %struct.jpeg_color_converter*, %struct.jpeg_downsampler*, %struct.jpeg_forward_dct*, %struct.jpeg_entropy_encoder* }
%struct.jpeg_error_mgr = type { void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*, i32)*, void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*, i8*)*, void (%struct.jpeg_common_struct*)*, i32, %union.anon, i32, i64, i8**, i32, i8**, i32, i32 }
%struct.jpeg_common_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32 }
%struct.jpeg_memory_mgr = type { i8* (%struct.jpeg_common_struct*, i32, i64)*, i8* (%struct.jpeg_common_struct*, i32, i64)*, i8** (%struct.jpeg_common_struct*, i32, i32, i32)*, [64 x i16]** (%struct.jpeg_common_struct*, i32, i32, i32)*, %struct.jvirt_sarray_control* (%struct.jpeg_common_struct*, i32, i32, i32, i32, i32)*, %struct.jvirt_barray_control* (%struct.jpeg_common_struct*, i32, i32, i32, i32, i32)*, {}*, i8** (%struct.jpeg_common_struct*, %struct.jvirt_sarray_control*, i32, i32, i32)*, [64 x i16]** (%struct.jpeg_common_struct*, %struct.jvirt_barray_control*, i32, i32, i32)*, void (%struct.jpeg_common_struct*, i32)*, {}*, i64 }
%struct.jvirt_sarray_control = type opaque
%struct.jvirt_barray_control = type opaque
%struct.jpeg_progress_mgr = type { {}*, i64, i64, i32, i32 }
%union.anon = type { [8 x i32], [48 x i8] }
%struct.jpeg_destination_mgr = type { i8*, i64, void (%struct.jpeg_compress_struct*)*, i32 (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)* }
%struct.jpeg_component_info = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.JQUANT_TBL*, i8* }
%struct.JQUANT_TBL = type { [64 x i16], i32 }
%struct.JHUFF_TBL = type { [17 x i8], [256 x i8], i32 }
%struct.jpeg_scan_info = type { i32, [4 x i32], i32, i32, i32, i32 }
%struct.jpeg_comp_master = type opaque
%struct.jpeg_c_main_controller = type opaque
%struct.jpeg_c_prep_controller = type opaque
%struct.jpeg_c_coef_controller = type opaque
%struct.jpeg_marker_writer = type opaque
%struct.jpeg_color_converter = type opaque
%struct.jpeg_downsampler = type opaque
%struct.jpeg_forward_dct = type opaque
%struct.jpeg_entropy_encoder = type opaque
%struct.cjpeg_source_struct = type { void (%struct.jpeg_compress_struct*, %struct.cjpeg_source_struct*)*, i32 (%struct.jpeg_compress_struct*, %struct.cjpeg_source_struct*)*, void (%struct.jpeg_compress_struct*, %struct.cjpeg_source_struct*)*, %struct.__sFILE*, i8**, i32 }

@progname = internal global i8* null, align 8
@.str = private unnamed_addr constant [6 x i8] c"cjpeg\00", align 1
@cdjpeg_message_table = internal constant [44 x i8*] [i8* null, i8* getelementptr inbounds ([32 x i8]* @.str59, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8]* @.str60, i32 0, i32 0), i8* getelementptr inbounds ([36 x i8]* @.str61, i32 0, i32 0), i8* getelementptr inbounds ([42 x i8]* @.str62, i32 0, i32 0), i8* getelementptr inbounds ([36 x i8]* @.str63, i32 0, i32 0), i8* getelementptr inbounds ([41 x i8]* @.str64, i32 0, i32 0), i8* getelementptr inbounds ([40 x i8]* @.str65, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8]* @.str66, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8]* @.str67, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8]* @.str68, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8]* @.str69, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8]* @.str70, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8]* @.str71, i32 0, i32 0), i8* getelementptr inbounds ([36 x i8]* @.str72, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8]* @.str73, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8]* @.str74, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8]* @.str75, i32 0, i32 0), i8* getelementptr inbounds ([48 x i8]* @.str76, i32 0, i32 0), i8* getelementptr inbounds ([44 x i8]* @.str77, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8]* @.str78, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8]* @.str79, i32 0, i32 0), i8* getelementptr inbounds ([40 x i8]* @.str80, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8]* @.str81, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8]* @.str82, i32 0, i32 0), i8* getelementptr inbounds ([36 x i8]* @.str83, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8]* @.str84, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8]* @.str85, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8]* @.str86, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8]* @.str87, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8]* @.str88, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8]* @.str89, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8]* @.str90, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8]* @.str91, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8]* @.str92, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8]* @.str93, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8]* @.str94, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8]* @.str95, i32 0, i32 0), i8* getelementptr inbounds ([51 x i8]* @.str96, i32 0, i32 0), i8* getelementptr inbounds ([53 x i8]* @.str97, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8]* @.str98, i32 0, i32 0), i8* getelementptr inbounds ([59 x i8]* @.str99, i32 0, i32 0), i8* getelementptr inbounds ([31 x i8]* @.str100, i32 0, i32 0), i8* null], align 16
@__stderrp = external global %struct.__sFILE*
@.str1 = private unnamed_addr constant [25 x i8] c"%s: only one input file\0A\00", align 1
@.str2 = private unnamed_addr constant [3 x i8] c"rb\00", align 1
@.str3 = private unnamed_addr constant [19 x i8] c"%s: can't open %s\0A\00", align 1
@outfilename = internal global i8* null, align 8
@.str4 = private unnamed_addr constant [3 x i8] c"wb\00", align 1
@__stdinp = external global %struct.__sFILE*
@__stdoutp = external global %struct.__sFILE*
@is_targa = internal global i32 0, align 4
@.str5 = private unnamed_addr constant [22 x i8] c"usage: %s [switches] \00", align 1
@.str6 = private unnamed_addr constant [13 x i8] c"[inputfile]\0A\00", align 1
@.str7 = private unnamed_addr constant [38 x i8] c"Switches (names may be abbreviated):\0A\00", align 1
@.str8 = private unnamed_addr constant [69 x i8] c"  -quality N     Compression quality (0..100; 5-95 is useful range)\0A\00", align 1
@.str9 = private unnamed_addr constant [46 x i8] c"  -grayscale     Create monochrome JPEG file\0A\00", align 1
@.str10 = private unnamed_addr constant [78 x i8] c"  -optimize      Optimize Huffman table (smaller file, but slow compression)\0A\00", align 1
@.str11 = private unnamed_addr constant [47 x i8] c"  -progressive   Create progressive JPEG file\0A\00", align 1
@.str12 = private unnamed_addr constant [66 x i8] c"  -targa         Input file is Targa format (usually not needed)\0A\00", align 1
@.str13 = private unnamed_addr constant [30 x i8] c"Switches for advanced users:\0A\00", align 1
@.str14 = private unnamed_addr constant [43 x i8] c"  -dct int       Use integer DCT method%s\0A\00", align 1
@.str15 = private unnamed_addr constant [11 x i8] c" (default)\00", align 1
@.str16 = private unnamed_addr constant [57 x i8] c"  -dct fast      Use fast integer DCT (less accurate)%s\0A\00", align 1
@.str17 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str18 = private unnamed_addr constant [50 x i8] c"  -dct float     Use floating-point DCT method%s\0A\00", align 1
@.str19 = private unnamed_addr constant [68 x i8] c"  -restart N     Set restart interval in rows, or in blocks with B\0A\00", align 1
@.str20 = private unnamed_addr constant [63 x i8] c"  -smooth N      Smooth dithered input (N=1..100 is strength)\0A\00", align 1
@.str21 = private unnamed_addr constant [52 x i8] c"  -maxmemory N   Maximum memory to use (in kbytes)\0A\00", align 1
@.str22 = private unnamed_addr constant [47 x i8] c"  -outfile name  Specify name for output file\0A\00", align 1
@.str23 = private unnamed_addr constant [44 x i8] c"  -verbose  or  -debug   Emit debug output\0A\00", align 1
@.str24 = private unnamed_addr constant [23 x i8] c"Switches for wizards:\0A\00", align 1
@.str25 = private unnamed_addr constant [40 x i8] c"  -baseline      Force baseline output\0A\00", align 1
@.str26 = private unnamed_addr constant [56 x i8] c"  -qtables file  Use quantization tables given in file\0A\00", align 1
@.str27 = private unnamed_addr constant [56 x i8] c"  -qslots N[,...]    Set component quantization tables\0A\00", align 1
@.str28 = private unnamed_addr constant [53 x i8] c"  -sample HxV[,...]  Set component sampling factors\0A\00", align 1
@.str29 = private unnamed_addr constant [57 x i8] c"  -scans file    Create multi-scan JPEG per script file\0A\00", align 1
@.str30 = private unnamed_addr constant [11 x i8] c"arithmetic\00", align 1
@.str31 = private unnamed_addr constant [44 x i8] c"%s: sorry, arithmetic coding not supported\0A\00", align 1
@.str32 = private unnamed_addr constant [9 x i8] c"baseline\00", align 1
@.str33 = private unnamed_addr constant [4 x i8] c"dct\00", align 1
@.str34 = private unnamed_addr constant [4 x i8] c"int\00", align 1
@.str35 = private unnamed_addr constant [5 x i8] c"fast\00", align 1
@.str36 = private unnamed_addr constant [6 x i8] c"float\00", align 1
@.str37 = private unnamed_addr constant [6 x i8] c"debug\00", align 1
@.str38 = private unnamed_addr constant [8 x i8] c"verbose\00", align 1
@parse_switches.printed_version = internal global i32 0, align 4
@.str39 = private unnamed_addr constant [47 x i8] c"Independent JPEG Group's CJPEG, version %s\0A%s\0A\00", align 1
@.str40 = private unnamed_addr constant [13 x i8] c"6a  7-Feb-96\00", align 1
@.str41 = private unnamed_addr constant [35 x i8] c"Copyright (C) 1996, Thomas G. Lane\00", align 1
@.str42 = private unnamed_addr constant [10 x i8] c"grayscale\00", align 1
@.str43 = private unnamed_addr constant [10 x i8] c"greyscale\00", align 1
@.str44 = private unnamed_addr constant [10 x i8] c"maxmemory\00", align 1
@.str45 = private unnamed_addr constant [6 x i8] c"%ld%c\00", align 1
@.str46 = private unnamed_addr constant [9 x i8] c"optimize\00", align 1
@.str47 = private unnamed_addr constant [9 x i8] c"optimise\00", align 1
@.str48 = private unnamed_addr constant [8 x i8] c"outfile\00", align 1
@.str49 = private unnamed_addr constant [12 x i8] c"progressive\00", align 1
@.str50 = private unnamed_addr constant [8 x i8] c"quality\00", align 1
@.str51 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str52 = private unnamed_addr constant [7 x i8] c"qslots\00", align 1
@.str53 = private unnamed_addr constant [8 x i8] c"qtables\00", align 1
@.str54 = private unnamed_addr constant [8 x i8] c"restart\00", align 1
@.str55 = private unnamed_addr constant [7 x i8] c"sample\00", align 1
@.str56 = private unnamed_addr constant [6 x i8] c"scans\00", align 1
@.str57 = private unnamed_addr constant [7 x i8] c"smooth\00", align 1
@.str58 = private unnamed_addr constant [6 x i8] c"targa\00", align 1
@.str59 = private unnamed_addr constant [32 x i8] c"Unsupported BMP colormap format\00", align 1
@.str60 = private unnamed_addr constant [43 x i8] c"Only 8- and 24-bit BMP files are supported\00", align 1
@.str61 = private unnamed_addr constant [36 x i8] c"Invalid BMP file: bad header length\00", align 1
@.str62 = private unnamed_addr constant [42 x i8] c"Invalid BMP file: biPlanes not equal to 1\00", align 1
@.str63 = private unnamed_addr constant [36 x i8] c"BMP output must be grayscale or RGB\00", align 1
@.str64 = private unnamed_addr constant [41 x i8] c"Sorry, compressed BMPs not yet supported\00", align 1
@.str65 = private unnamed_addr constant [40 x i8] c"Not a BMP file - does not start with BM\00", align 1
@.str66 = private unnamed_addr constant [23 x i8] c"%ux%u 24-bit BMP image\00", align 1
@.str67 = private unnamed_addr constant [34 x i8] c"%ux%u 8-bit colormapped BMP image\00", align 1
@.str68 = private unnamed_addr constant [27 x i8] c"%ux%u 24-bit OS2 BMP image\00", align 1
@.str69 = private unnamed_addr constant [38 x i8] c"%ux%u 8-bit colormapped OS2 BMP image\00", align 1
@.str70 = private unnamed_addr constant [24 x i8] c"GIF output got confused\00", align 1
@.str71 = private unnamed_addr constant [22 x i8] c"Bogus GIF codesize %d\00", align 1
@.str72 = private unnamed_addr constant [36 x i8] c"GIF output must be grayscale or RGB\00", align 1
@.str73 = private unnamed_addr constant [27 x i8] c"Too few images in GIF file\00", align 1
@.str74 = private unnamed_addr constant [15 x i8] c"Not a GIF file\00", align 1
@.str75 = private unnamed_addr constant [19 x i8] c"%ux%ux%d GIF image\00", align 1
@.str76 = private unnamed_addr constant [48 x i8] c"Warning: unexpected GIF version number '%c%c%c'\00", align 1
@.str77 = private unnamed_addr constant [44 x i8] c"Ignoring GIF extension block of type 0x%02x\00", align 1
@.str78 = private unnamed_addr constant [35 x i8] c"Caution: nonsquare pixels in input\00", align 1
@.str79 = private unnamed_addr constant [25 x i8] c"Corrupt data in GIF file\00", align 1
@.str80 = private unnamed_addr constant [40 x i8] c"Bogus char 0x%02x in GIF file, ignoring\00", align 1
@.str81 = private unnamed_addr constant [27 x i8] c"Premature end of GIF image\00", align 1
@.str82 = private unnamed_addr constant [20 x i8] c"Ran out of GIF bits\00", align 1
@.str83 = private unnamed_addr constant [36 x i8] c"PPM output must be grayscale or RGB\00", align 1
@.str84 = private unnamed_addr constant [28 x i8] c"Nonnumeric data in PPM file\00", align 1
@.str85 = private unnamed_addr constant [15 x i8] c"Not a PPM file\00", align 1
@.str86 = private unnamed_addr constant [16 x i8] c"%ux%u PGM image\00", align 1
@.str87 = private unnamed_addr constant [21 x i8] c"%ux%u text PGM image\00", align 1
@.str88 = private unnamed_addr constant [16 x i8] c"%ux%u PPM image\00", align 1
@.str89 = private unnamed_addr constant [21 x i8] c"%ux%u text PPM image\00", align 1
@.str90 = private unnamed_addr constant [34 x i8] c"Unsupported Targa colormap format\00", align 1
@.str91 = private unnamed_addr constant [34 x i8] c"Invalid or unsupported Targa file\00", align 1
@.str92 = private unnamed_addr constant [38 x i8] c"Targa output must be grayscale or RGB\00", align 1
@.str93 = private unnamed_addr constant [22 x i8] c"%ux%u RGB Targa image\00", align 1
@.str94 = private unnamed_addr constant [28 x i8] c"%ux%u grayscale Targa image\00", align 1
@.str95 = private unnamed_addr constant [30 x i8] c"%ux%u colormapped Targa image\00", align 1
@.str96 = private unnamed_addr constant [51 x i8] c"Color map file is invalid or of unsupported format\00", align 1
@.str97 = private unnamed_addr constant [53 x i8] c"Output file format cannot handle %d colormap entries\00", align 1
@.str98 = private unnamed_addr constant [14 x i8] c"ungetc failed\00", align 1
@.str99 = private unnamed_addr constant [59 x i8] c"Unrecognized input file format --- perhaps you need -targa\00", align 1
@.str100 = private unnamed_addr constant [31 x i8] c"Unsupported output file format\00", align 1

; Function Attrs: nounwind ssp uwtable
define i32 @main(i32 %argc, i8** %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  %cinfo = alloca %struct.jpeg_compress_struct, align 8
  %jerr = alloca %struct.jpeg_error_mgr, align 8
  %file_index = alloca i32, align 4
  %src_mgr = alloca %struct.cjpeg_source_struct*, align 8
  %input_file = alloca %struct.__sFILE*, align 8
  %output_file = alloca %struct.__sFILE*, align 8
  %num_scanlines = alloca i32, align 4
  store i32 0, i32* %retval
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  %0 = load i8*** %argv.addr, align 8
  %arrayidx = getelementptr inbounds i8** %0, i64 0
  %1 = load i8** %arrayidx, align 8
  store i8* %1, i8** @progname, align 8
  %2 = load i8** @progname, align 8
  %cmp = icmp eq i8* %2, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load i8** @progname, align 8
  %arrayidx1 = getelementptr inbounds i8* %3, i64 0
  %4 = load i8* %arrayidx1, align 1
  %conv = sext i8 %4 to i32
  %cmp2 = icmp eq i32 %conv, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i8* getelementptr inbounds ([6 x i8]* @.str, i32 0, i32 0), i8** @progname, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %call = call %struct.jpeg_error_mgr* @jpeg_std_error(%struct.jpeg_error_mgr* %jerr)
  %err = getelementptr inbounds %struct.jpeg_compress_struct* %cinfo, i32 0, i32 0
  store %struct.jpeg_error_mgr* %call, %struct.jpeg_error_mgr** %err, align 8
  call void @jpeg_CreateCompress(%struct.jpeg_compress_struct* %cinfo, i32 61, i64 496)
  %addon_message_table = getelementptr inbounds %struct.jpeg_error_mgr* %jerr, i32 0, i32 11
  store i8** getelementptr inbounds ([44 x i8*]* @cdjpeg_message_table, i32 0, i32 0), i8*** %addon_message_table, align 8
  %first_addon_message = getelementptr inbounds %struct.jpeg_error_mgr* %jerr, i32 0, i32 12
  store i32 1000, i32* %first_addon_message, align 4
  %last_addon_message = getelementptr inbounds %struct.jpeg_error_mgr* %jerr, i32 0, i32 13
  store i32 1043, i32* %last_addon_message, align 4
  %in_color_space = getelementptr inbounds %struct.jpeg_compress_struct* %cinfo, i32 0, i32 9
  store i32 2, i32* %in_color_space, align 4
  call void @jpeg_set_defaults(%struct.jpeg_compress_struct* %cinfo)
  %5 = load i32* %argc.addr, align 4
  %6 = load i8*** %argv.addr, align 8
  %call4 = call i32 @parse_switches(%struct.jpeg_compress_struct* %cinfo, i32 %5, i8** %6, i32 0, i32 0)
  store i32 %call4, i32* %file_index, align 4
  %7 = load i32* %file_index, align 4
  %8 = load i32* %argc.addr, align 4
  %sub = sub nsw i32 %8, 1
  %cmp5 = icmp slt i32 %7, %sub
  br i1 %cmp5, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.end
  %9 = load %struct.__sFILE** @__stderrp, align 8
  %10 = load i8** @progname, align 8
  %call8 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %9, i8* getelementptr inbounds ([25 x i8]* @.str1, i32 0, i32 0), i8* %10)
  call void @usage()
  br label %if.end9

if.end9:                                          ; preds = %if.then7, %if.end
  %11 = load i32* %file_index, align 4
  %12 = load i32* %argc.addr, align 4
  %cmp10 = icmp slt i32 %11, %12
  br i1 %cmp10, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end9
  %13 = load i32* %file_index, align 4
  %idxprom = sext i32 %13 to i64
  %14 = load i8*** %argv.addr, align 8
  %arrayidx13 = getelementptr inbounds i8** %14, i64 %idxprom
  %15 = load i8** %arrayidx13, align 8
  %call14 = call %struct.__sFILE* @"\01_fopen"(i8* %15, i8* getelementptr inbounds ([3 x i8]* @.str2, i32 0, i32 0))
  store %struct.__sFILE* %call14, %struct.__sFILE** %input_file, align 8
  %cmp15 = icmp eq %struct.__sFILE* %call14, null
  br i1 %cmp15, label %if.then17, label %if.end21

if.then17:                                        ; preds = %if.then12
  %16 = load %struct.__sFILE** @__stderrp, align 8
  %17 = load i8** @progname, align 8
  %18 = load i32* %file_index, align 4
  %idxprom18 = sext i32 %18 to i64
  %19 = load i8*** %argv.addr, align 8
  %arrayidx19 = getelementptr inbounds i8** %19, i64 %idxprom18
  %20 = load i8** %arrayidx19, align 8
  %call20 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %16, i8* getelementptr inbounds ([19 x i8]* @.str3, i32 0, i32 0), i8* %17, i8* %20)
  call void @exit(i32 1) #3
  unreachable

if.end21:                                         ; preds = %if.then12
  br label %if.end23

if.else:                                          ; preds = %if.end9
  %call22 = call %struct.__sFILE* @read_stdin()
  store %struct.__sFILE* %call22, %struct.__sFILE** %input_file, align 8
  br label %if.end23

if.end23:                                         ; preds = %if.else, %if.end21
  %21 = load i8** @outfilename, align 8
  %cmp24 = icmp ne i8* %21, null
  br i1 %cmp24, label %if.then26, label %if.else33

if.then26:                                        ; preds = %if.end23
  %22 = load i8** @outfilename, align 8
  %call27 = call %struct.__sFILE* @"\01_fopen"(i8* %22, i8* getelementptr inbounds ([3 x i8]* @.str4, i32 0, i32 0))
  store %struct.__sFILE* %call27, %struct.__sFILE** %output_file, align 8
  %cmp28 = icmp eq %struct.__sFILE* %call27, null
  br i1 %cmp28, label %if.then30, label %if.end32

if.then30:                                        ; preds = %if.then26
  %23 = load %struct.__sFILE** @__stderrp, align 8
  %24 = load i8** @progname, align 8
  %25 = load i8** @outfilename, align 8
  %call31 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %23, i8* getelementptr inbounds ([19 x i8]* @.str3, i32 0, i32 0), i8* %24, i8* %25)
  call void @exit(i32 1) #3
  unreachable

if.end32:                                         ; preds = %if.then26
  br label %if.end35

if.else33:                                        ; preds = %if.end23
  %call34 = call %struct.__sFILE* @write_stdout()
  store %struct.__sFILE* %call34, %struct.__sFILE** %output_file, align 8
  br label %if.end35

if.end35:                                         ; preds = %if.else33, %if.end32
  %26 = load %struct.__sFILE** %input_file, align 8
  %call36 = call %struct.cjpeg_source_struct* @select_file_type(%struct.jpeg_compress_struct* %cinfo, %struct.__sFILE* %26)
  store %struct.cjpeg_source_struct* %call36, %struct.cjpeg_source_struct** %src_mgr, align 8
  %27 = load %struct.__sFILE** %input_file, align 8
  %28 = load %struct.cjpeg_source_struct** %src_mgr, align 8
  %input_file37 = getelementptr inbounds %struct.cjpeg_source_struct* %28, i32 0, i32 3
  store %struct.__sFILE* %27, %struct.__sFILE** %input_file37, align 8
  %29 = load %struct.cjpeg_source_struct** %src_mgr, align 8
  %start_input = getelementptr inbounds %struct.cjpeg_source_struct* %29, i32 0, i32 0
  %30 = load void (%struct.jpeg_compress_struct*, %struct.cjpeg_source_struct*)** %start_input, align 8
  %31 = load %struct.cjpeg_source_struct** %src_mgr, align 8
  call void %30(%struct.jpeg_compress_struct* %cinfo, %struct.cjpeg_source_struct* %31)
  call void @jpeg_default_colorspace(%struct.jpeg_compress_struct* %cinfo)
  %32 = load i32* %argc.addr, align 4
  %33 = load i8*** %argv.addr, align 8
  %call38 = call i32 @parse_switches(%struct.jpeg_compress_struct* %cinfo, i32 %32, i8** %33, i32 0, i32 1)
  store i32 %call38, i32* %file_index, align 4
  %34 = load %struct.__sFILE** %output_file, align 8
  call void @jpeg_stdio_dest(%struct.jpeg_compress_struct* %cinfo, %struct.__sFILE* %34)
  call void @jpeg_start_compress(%struct.jpeg_compress_struct* %cinfo, i32 1)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end35
  %next_scanline = getelementptr inbounds %struct.jpeg_compress_struct* %cinfo, i32 0, i32 36
  %35 = load i32* %next_scanline, align 4
  %image_height = getelementptr inbounds %struct.jpeg_compress_struct* %cinfo, i32 0, i32 7
  %36 = load i32* %image_height, align 4
  %cmp39 = icmp ult i32 %35, %36
  br i1 %cmp39, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %37 = load %struct.cjpeg_source_struct** %src_mgr, align 8
  %get_pixel_rows = getelementptr inbounds %struct.cjpeg_source_struct* %37, i32 0, i32 1
  %38 = load i32 (%struct.jpeg_compress_struct*, %struct.cjpeg_source_struct*)** %get_pixel_rows, align 8
  %39 = load %struct.cjpeg_source_struct** %src_mgr, align 8
  %call41 = call i32 %38(%struct.jpeg_compress_struct* %cinfo, %struct.cjpeg_source_struct* %39)
  store i32 %call41, i32* %num_scanlines, align 4
  %40 = load %struct.cjpeg_source_struct** %src_mgr, align 8
  %buffer = getelementptr inbounds %struct.cjpeg_source_struct* %40, i32 0, i32 4
  %41 = load i8*** %buffer, align 8
  %42 = load i32* %num_scanlines, align 4
  %call42 = call i32 @jpeg_write_scanlines(%struct.jpeg_compress_struct* %cinfo, i8** %41, i32 %42)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %43 = load %struct.cjpeg_source_struct** %src_mgr, align 8
  %finish_input = getelementptr inbounds %struct.cjpeg_source_struct* %43, i32 0, i32 2
  %44 = load void (%struct.jpeg_compress_struct*, %struct.cjpeg_source_struct*)** %finish_input, align 8
  %45 = load %struct.cjpeg_source_struct** %src_mgr, align 8
  call void %44(%struct.jpeg_compress_struct* %cinfo, %struct.cjpeg_source_struct* %45)
  call void @jpeg_finish_compress(%struct.jpeg_compress_struct* %cinfo)
  call void @jpeg_destroy_compress(%struct.jpeg_compress_struct* %cinfo)
  %46 = load %struct.__sFILE** %input_file, align 8
  %47 = load %struct.__sFILE** @__stdinp, align 8
  %cmp43 = icmp ne %struct.__sFILE* %46, %47
  br i1 %cmp43, label %if.then45, label %if.end47

if.then45:                                        ; preds = %while.end
  %48 = load %struct.__sFILE** %input_file, align 8
  %call46 = call i32 @fclose(%struct.__sFILE* %48)
  br label %if.end47

if.end47:                                         ; preds = %if.then45, %while.end
  %49 = load %struct.__sFILE** %output_file, align 8
  %50 = load %struct.__sFILE** @__stdoutp, align 8
  %cmp48 = icmp ne %struct.__sFILE* %49, %50
  br i1 %cmp48, label %if.then50, label %if.end52

if.then50:                                        ; preds = %if.end47
  %51 = load %struct.__sFILE** %output_file, align 8
  %call51 = call i32 @fclose(%struct.__sFILE* %51)
  br label %if.end52

if.end52:                                         ; preds = %if.then50, %if.end47
  %num_warnings = getelementptr inbounds %struct.jpeg_error_mgr* %jerr, i32 0, i32 8
  %52 = load i64* %num_warnings, align 8
  %tobool = icmp ne i64 %52, 0
  %cond = select i1 %tobool, i32 2, i32 0
  call void @exit(i32 %cond) #3
  unreachable

return:                                           ; No predecessors!
  %53 = load i32* %retval
  ret i32 %53
}

declare %struct.jpeg_error_mgr* @jpeg_std_error(%struct.jpeg_error_mgr*) #1

declare void @jpeg_CreateCompress(%struct.jpeg_compress_struct*, i32, i64) #1

declare void @jpeg_set_defaults(%struct.jpeg_compress_struct*) #1

; Function Attrs: nounwind ssp uwtable
define internal i32 @parse_switches(%struct.jpeg_compress_struct* %cinfo, i32 %argc, i8** %argv, i32 %last_file_arg_seen, i32 %for_real) #0 {
entry:
  %cinfo.addr = alloca %struct.jpeg_compress_struct*, align 8
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  %last_file_arg_seen.addr = alloca i32, align 4
  %for_real.addr = alloca i32, align 4
  %argn = alloca i32, align 4
  %arg = alloca i8*, align 8
  %quality = alloca i32, align 4
  %q_scale_factor = alloca i32, align 4
  %force_baseline = alloca i32, align 4
  %simple_progressive = alloca i32, align 4
  %qtablefile = alloca i8*, align 8
  %qslotsarg = alloca i8*, align 8
  %samplearg = alloca i8*, align 8
  %scansarg = alloca i8*, align 8
  %lval = alloca i64, align 8
  %ch = alloca i8, align 1
  %lval154 = alloca i64, align 8
  %ch155 = alloca i8, align 1
  %val = alloca i32, align 4
  store %struct.jpeg_compress_struct* %cinfo, %struct.jpeg_compress_struct** %cinfo.addr, align 8
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  store i32 %last_file_arg_seen, i32* %last_file_arg_seen.addr, align 4
  store i32 %for_real, i32* %for_real.addr, align 4
  store i8* null, i8** %qtablefile, align 8
  store i8* null, i8** %qslotsarg, align 8
  store i8* null, i8** %samplearg, align 8
  store i8* null, i8** %scansarg, align 8
  store i32 75, i32* %quality, align 4
  store i32 100, i32* %q_scale_factor, align 4
  store i32 0, i32* %force_baseline, align 4
  store i32 0, i32* %simple_progressive, align 4
  store i32 0, i32* @is_targa, align 4
  store i8* null, i8** @outfilename, align 8
  %0 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %err = getelementptr inbounds %struct.jpeg_compress_struct* %0, i32 0, i32 0
  %1 = load %struct.jpeg_error_mgr** %err, align 8
  %trace_level = getelementptr inbounds %struct.jpeg_error_mgr* %1, i32 0, i32 7
  store i32 0, i32* %trace_level, align 4
  store i32 1, i32* %argn, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32* %argn, align 4
  %3 = load i32* %argc.addr, align 4
  %cmp = icmp slt i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i32* %argn, align 4
  %idxprom = sext i32 %4 to i64
  %5 = load i8*** %argv.addr, align 8
  %arrayidx = getelementptr inbounds i8** %5, i64 %idxprom
  %6 = load i8** %arrayidx, align 8
  store i8* %6, i8** %arg, align 8
  %7 = load i8** %arg, align 8
  %8 = load i8* %7, align 1
  %conv = sext i8 %8 to i32
  %cmp1 = icmp ne i32 %conv, 45
  br i1 %cmp1, label %if.then, label %if.end6

if.then:                                          ; preds = %for.body
  %9 = load i32* %argn, align 4
  %10 = load i32* %last_file_arg_seen.addr, align 4
  %cmp3 = icmp sle i32 %9, %10
  br i1 %cmp3, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.then
  store i8* null, i8** @outfilename, align 8
  br label %for.inc

if.end:                                           ; preds = %if.then
  br label %for.end

if.end6:                                          ; preds = %for.body
  %11 = load i8** %arg, align 8
  %incdec.ptr = getelementptr inbounds i8* %11, i32 1
  store i8* %incdec.ptr, i8** %arg, align 8
  %12 = load i8** %arg, align 8
  %call = call i32 @keymatch(i8* %12, i8* getelementptr inbounds ([11 x i8]* @.str30, i32 0, i32 0), i32 1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then7, label %if.else

if.then7:                                         ; preds = %if.end6
  %13 = load %struct.__sFILE** @__stderrp, align 8
  %14 = load i8** @progname, align 8
  %call8 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %13, i8* getelementptr inbounds ([44 x i8]* @.str31, i32 0, i32 0), i8* %14)
  call void @exit(i32 1) #3
  unreachable

if.else:                                          ; preds = %if.end6
  %15 = load i8** %arg, align 8
  %call9 = call i32 @keymatch(i8* %15, i8* getelementptr inbounds ([9 x i8]* @.str32, i32 0, i32 0), i32 1)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.then11, label %if.else12

if.then11:                                        ; preds = %if.else
  store i32 1, i32* %force_baseline, align 4
  br label %if.end253

if.else12:                                        ; preds = %if.else
  %16 = load i8** %arg, align 8
  %call13 = call i32 @keymatch(i8* %16, i8* getelementptr inbounds ([4 x i8]* @.str33, i32 0, i32 0), i32 2)
  %tobool14 = icmp ne i32 %call13, 0
  br i1 %tobool14, label %if.then15, label %if.else43

if.then15:                                        ; preds = %if.else12
  %17 = load i32* %argn, align 4
  %inc = add nsw i32 %17, 1
  store i32 %inc, i32* %argn, align 4
  %18 = load i32* %argc.addr, align 4
  %cmp16 = icmp sge i32 %inc, %18
  br i1 %cmp16, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.then15
  call void @usage()
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.then15
  %19 = load i32* %argn, align 4
  %idxprom20 = sext i32 %19 to i64
  %20 = load i8*** %argv.addr, align 8
  %arrayidx21 = getelementptr inbounds i8** %20, i64 %idxprom20
  %21 = load i8** %arrayidx21, align 8
  %call22 = call i32 @keymatch(i8* %21, i8* getelementptr inbounds ([4 x i8]* @.str34, i32 0, i32 0), i32 1)
  %tobool23 = icmp ne i32 %call22, 0
  br i1 %tobool23, label %if.then24, label %if.else25

if.then24:                                        ; preds = %if.end19
  %22 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %dct_method = getelementptr inbounds %struct.jpeg_compress_struct* %22, i32 0, i32 28
  store i32 0, i32* %dct_method, align 4
  br label %if.end42

if.else25:                                        ; preds = %if.end19
  %23 = load i32* %argn, align 4
  %idxprom26 = sext i32 %23 to i64
  %24 = load i8*** %argv.addr, align 8
  %arrayidx27 = getelementptr inbounds i8** %24, i64 %idxprom26
  %25 = load i8** %arrayidx27, align 8
  %call28 = call i32 @keymatch(i8* %25, i8* getelementptr inbounds ([5 x i8]* @.str35, i32 0, i32 0), i32 2)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.then30, label %if.else32

if.then30:                                        ; preds = %if.else25
  %26 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %dct_method31 = getelementptr inbounds %struct.jpeg_compress_struct* %26, i32 0, i32 28
  store i32 1, i32* %dct_method31, align 4
  br label %if.end41

if.else32:                                        ; preds = %if.else25
  %27 = load i32* %argn, align 4
  %idxprom33 = sext i32 %27 to i64
  %28 = load i8*** %argv.addr, align 8
  %arrayidx34 = getelementptr inbounds i8** %28, i64 %idxprom33
  %29 = load i8** %arrayidx34, align 8
  %call35 = call i32 @keymatch(i8* %29, i8* getelementptr inbounds ([6 x i8]* @.str36, i32 0, i32 0), i32 2)
  %tobool36 = icmp ne i32 %call35, 0
  br i1 %tobool36, label %if.then37, label %if.else39

if.then37:                                        ; preds = %if.else32
  %30 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %dct_method38 = getelementptr inbounds %struct.jpeg_compress_struct* %30, i32 0, i32 28
  store i32 2, i32* %dct_method38, align 4
  br label %if.end40

if.else39:                                        ; preds = %if.else32
  call void @usage()
  br label %if.end40

if.end40:                                         ; preds = %if.else39, %if.then37
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.then30
  br label %if.end42

if.end42:                                         ; preds = %if.end41, %if.then24
  br label %if.end252

if.else43:                                        ; preds = %if.else12
  %31 = load i8** %arg, align 8
  %call44 = call i32 @keymatch(i8* %31, i8* getelementptr inbounds ([6 x i8]* @.str37, i32 0, i32 0), i32 1)
  %tobool45 = icmp ne i32 %call44, 0
  br i1 %tobool45, label %if.then48, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else43
  %32 = load i8** %arg, align 8
  %call46 = call i32 @keymatch(i8* %32, i8* getelementptr inbounds ([8 x i8]* @.str38, i32 0, i32 0), i32 1)
  %tobool47 = icmp ne i32 %call46, 0
  br i1 %tobool47, label %if.then48, label %if.else56

if.then48:                                        ; preds = %lor.lhs.false, %if.else43
  %33 = load i32* @parse_switches.printed_version, align 4
  %tobool49 = icmp ne i32 %33, 0
  br i1 %tobool49, label %if.end52, label %if.then50

if.then50:                                        ; preds = %if.then48
  %34 = load %struct.__sFILE** @__stderrp, align 8
  %call51 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %34, i8* getelementptr inbounds ([47 x i8]* @.str39, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8]* @.str40, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8]* @.str41, i32 0, i32 0))
  store i32 1, i32* @parse_switches.printed_version, align 4
  br label %if.end52

if.end52:                                         ; preds = %if.then50, %if.then48
  %35 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %err53 = getelementptr inbounds %struct.jpeg_compress_struct* %35, i32 0, i32 0
  %36 = load %struct.jpeg_error_mgr** %err53, align 8
  %trace_level54 = getelementptr inbounds %struct.jpeg_error_mgr* %36, i32 0, i32 7
  %37 = load i32* %trace_level54, align 4
  %inc55 = add nsw i32 %37, 1
  store i32 %inc55, i32* %trace_level54, align 4
  br label %if.end251

if.else56:                                        ; preds = %lor.lhs.false
  %38 = load i8** %arg, align 8
  %call57 = call i32 @keymatch(i8* %38, i8* getelementptr inbounds ([10 x i8]* @.str42, i32 0, i32 0), i32 2)
  %tobool58 = icmp ne i32 %call57, 0
  br i1 %tobool58, label %if.then62, label %lor.lhs.false59

lor.lhs.false59:                                  ; preds = %if.else56
  %39 = load i8** %arg, align 8
  %call60 = call i32 @keymatch(i8* %39, i8* getelementptr inbounds ([10 x i8]* @.str43, i32 0, i32 0), i32 2)
  %tobool61 = icmp ne i32 %call60, 0
  br i1 %tobool61, label %if.then62, label %if.else63

if.then62:                                        ; preds = %lor.lhs.false59, %if.else56
  %40 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  call void @jpeg_set_colorspace(%struct.jpeg_compress_struct* %40, i32 1)
  br label %if.end250

if.else63:                                        ; preds = %lor.lhs.false59
  %41 = load i8** %arg, align 8
  %call64 = call i32 @keymatch(i8* %41, i8* getelementptr inbounds ([10 x i8]* @.str44, i32 0, i32 0), i32 3)
  %tobool65 = icmp ne i32 %call64, 0
  br i1 %tobool65, label %if.then66, label %if.else89

if.then66:                                        ; preds = %if.else63
  store i8 120, i8* %ch, align 1
  %42 = load i32* %argn, align 4
  %inc67 = add nsw i32 %42, 1
  store i32 %inc67, i32* %argn, align 4
  %43 = load i32* %argc.addr, align 4
  %cmp68 = icmp sge i32 %inc67, %43
  br i1 %cmp68, label %if.then70, label %if.end71

if.then70:                                        ; preds = %if.then66
  call void @usage()
  br label %if.end71

if.end71:                                         ; preds = %if.then70, %if.then66
  %44 = load i32* %argn, align 4
  %idxprom72 = sext i32 %44 to i64
  %45 = load i8*** %argv.addr, align 8
  %arrayidx73 = getelementptr inbounds i8** %45, i64 %idxprom72
  %46 = load i8** %arrayidx73, align 8
  %call74 = call i32 (i8*, i8*, ...)* @sscanf(i8* %46, i8* getelementptr inbounds ([6 x i8]* @.str45, i32 0, i32 0), i64* %lval, i8* %ch)
  %cmp75 = icmp slt i32 %call74, 1
  br i1 %cmp75, label %if.then77, label %if.end78

if.then77:                                        ; preds = %if.end71
  call void @usage()
  br label %if.end78

if.end78:                                         ; preds = %if.then77, %if.end71
  %47 = load i8* %ch, align 1
  %conv79 = sext i8 %47 to i32
  %cmp80 = icmp eq i32 %conv79, 109
  br i1 %cmp80, label %if.then86, label %lor.lhs.false82

lor.lhs.false82:                                  ; preds = %if.end78
  %48 = load i8* %ch, align 1
  %conv83 = sext i8 %48 to i32
  %cmp84 = icmp eq i32 %conv83, 77
  br i1 %cmp84, label %if.then86, label %if.end87

if.then86:                                        ; preds = %lor.lhs.false82, %if.end78
  %49 = load i64* %lval, align 8
  %mul = mul nsw i64 %49, 1000
  store i64 %mul, i64* %lval, align 8
  br label %if.end87

if.end87:                                         ; preds = %if.then86, %lor.lhs.false82
  %50 = load i64* %lval, align 8
  %mul88 = mul nsw i64 %50, 1000
  %51 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %mem = getelementptr inbounds %struct.jpeg_compress_struct* %51, i32 0, i32 1
  %52 = load %struct.jpeg_memory_mgr** %mem, align 8
  %max_memory_to_use = getelementptr inbounds %struct.jpeg_memory_mgr* %52, i32 0, i32 11
  store i64 %mul88, i64* %max_memory_to_use, align 8
  br label %if.end249

if.else89:                                        ; preds = %if.else63
  %53 = load i8** %arg, align 8
  %call90 = call i32 @keymatch(i8* %53, i8* getelementptr inbounds ([9 x i8]* @.str46, i32 0, i32 0), i32 1)
  %tobool91 = icmp ne i32 %call90, 0
  br i1 %tobool91, label %if.then95, label %lor.lhs.false92

lor.lhs.false92:                                  ; preds = %if.else89
  %54 = load i8** %arg, align 8
  %call93 = call i32 @keymatch(i8* %54, i8* getelementptr inbounds ([9 x i8]* @.str47, i32 0, i32 0), i32 1)
  %tobool94 = icmp ne i32 %call93, 0
  br i1 %tobool94, label %if.then95, label %if.else96

if.then95:                                        ; preds = %lor.lhs.false92, %if.else89
  %55 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %optimize_coding = getelementptr inbounds %struct.jpeg_compress_struct* %55, i32 0, i32 25
  store i32 1, i32* %optimize_coding, align 4
  br label %if.end248

if.else96:                                        ; preds = %lor.lhs.false92
  %56 = load i8** %arg, align 8
  %call97 = call i32 @keymatch(i8* %56, i8* getelementptr inbounds ([8 x i8]* @.str48, i32 0, i32 0), i32 4)
  %tobool98 = icmp ne i32 %call97, 0
  br i1 %tobool98, label %if.then99, label %if.else107

if.then99:                                        ; preds = %if.else96
  %57 = load i32* %argn, align 4
  %inc100 = add nsw i32 %57, 1
  store i32 %inc100, i32* %argn, align 4
  %58 = load i32* %argc.addr, align 4
  %cmp101 = icmp sge i32 %inc100, %58
  br i1 %cmp101, label %if.then103, label %if.end104

if.then103:                                       ; preds = %if.then99
  call void @usage()
  br label %if.end104

if.end104:                                        ; preds = %if.then103, %if.then99
  %59 = load i32* %argn, align 4
  %idxprom105 = sext i32 %59 to i64
  %60 = load i8*** %argv.addr, align 8
  %arrayidx106 = getelementptr inbounds i8** %60, i64 %idxprom105
  %61 = load i8** %arrayidx106, align 8
  store i8* %61, i8** @outfilename, align 8
  br label %if.end247

if.else107:                                       ; preds = %if.else96
  %62 = load i8** %arg, align 8
  %call108 = call i32 @keymatch(i8* %62, i8* getelementptr inbounds ([12 x i8]* @.str49, i32 0, i32 0), i32 1)
  %tobool109 = icmp ne i32 %call108, 0
  br i1 %tobool109, label %if.then110, label %if.else111

if.then110:                                       ; preds = %if.else107
  store i32 1, i32* %simple_progressive, align 4
  br label %if.end246

if.else111:                                       ; preds = %if.else107
  %63 = load i8** %arg, align 8
  %call112 = call i32 @keymatch(i8* %63, i8* getelementptr inbounds ([8 x i8]* @.str50, i32 0, i32 0), i32 1)
  %tobool113 = icmp ne i32 %call112, 0
  br i1 %tobool113, label %if.then114, label %if.else128

if.then114:                                       ; preds = %if.else111
  %64 = load i32* %argn, align 4
  %inc115 = add nsw i32 %64, 1
  store i32 %inc115, i32* %argn, align 4
  %65 = load i32* %argc.addr, align 4
  %cmp116 = icmp sge i32 %inc115, %65
  br i1 %cmp116, label %if.then118, label %if.end119

if.then118:                                       ; preds = %if.then114
  call void @usage()
  br label %if.end119

if.end119:                                        ; preds = %if.then118, %if.then114
  %66 = load i32* %argn, align 4
  %idxprom120 = sext i32 %66 to i64
  %67 = load i8*** %argv.addr, align 8
  %arrayidx121 = getelementptr inbounds i8** %67, i64 %idxprom120
  %68 = load i8** %arrayidx121, align 8
  %call122 = call i32 (i8*, i8*, ...)* @sscanf(i8* %68, i8* getelementptr inbounds ([3 x i8]* @.str51, i32 0, i32 0), i32* %quality)
  %cmp123 = icmp ne i32 %call122, 1
  br i1 %cmp123, label %if.then125, label %if.end126

if.then125:                                       ; preds = %if.end119
  call void @usage()
  br label %if.end126

if.end126:                                        ; preds = %if.then125, %if.end119
  %69 = load i32* %quality, align 4
  %call127 = call i32 @jpeg_quality_scaling(i32 %69)
  store i32 %call127, i32* %q_scale_factor, align 4
  br label %if.end245

if.else128:                                       ; preds = %if.else111
  %70 = load i8** %arg, align 8
  %call129 = call i32 @keymatch(i8* %70, i8* getelementptr inbounds ([7 x i8]* @.str52, i32 0, i32 0), i32 2)
  %tobool130 = icmp ne i32 %call129, 0
  br i1 %tobool130, label %if.then131, label %if.else139

if.then131:                                       ; preds = %if.else128
  %71 = load i32* %argn, align 4
  %inc132 = add nsw i32 %71, 1
  store i32 %inc132, i32* %argn, align 4
  %72 = load i32* %argc.addr, align 4
  %cmp133 = icmp sge i32 %inc132, %72
  br i1 %cmp133, label %if.then135, label %if.end136

if.then135:                                       ; preds = %if.then131
  call void @usage()
  br label %if.end136

if.end136:                                        ; preds = %if.then135, %if.then131
  %73 = load i32* %argn, align 4
  %idxprom137 = sext i32 %73 to i64
  %74 = load i8*** %argv.addr, align 8
  %arrayidx138 = getelementptr inbounds i8** %74, i64 %idxprom137
  %75 = load i8** %arrayidx138, align 8
  store i8* %75, i8** %qslotsarg, align 8
  br label %if.end244

if.else139:                                       ; preds = %if.else128
  %76 = load i8** %arg, align 8
  %call140 = call i32 @keymatch(i8* %76, i8* getelementptr inbounds ([8 x i8]* @.str53, i32 0, i32 0), i32 2)
  %tobool141 = icmp ne i32 %call140, 0
  br i1 %tobool141, label %if.then142, label %if.else150

if.then142:                                       ; preds = %if.else139
  %77 = load i32* %argn, align 4
  %inc143 = add nsw i32 %77, 1
  store i32 %inc143, i32* %argn, align 4
  %78 = load i32* %argc.addr, align 4
  %cmp144 = icmp sge i32 %inc143, %78
  br i1 %cmp144, label %if.then146, label %if.end147

if.then146:                                       ; preds = %if.then142
  call void @usage()
  br label %if.end147

if.end147:                                        ; preds = %if.then146, %if.then142
  %79 = load i32* %argn, align 4
  %idxprom148 = sext i32 %79 to i64
  %80 = load i8*** %argv.addr, align 8
  %arrayidx149 = getelementptr inbounds i8** %80, i64 %idxprom148
  %81 = load i8** %arrayidx149, align 8
  store i8* %81, i8** %qtablefile, align 8
  br label %if.end243

if.else150:                                       ; preds = %if.else139
  %82 = load i8** %arg, align 8
  %call151 = call i32 @keymatch(i8* %82, i8* getelementptr inbounds ([8 x i8]* @.str54, i32 0, i32 0), i32 1)
  %tobool152 = icmp ne i32 %call151, 0
  br i1 %tobool152, label %if.then153, label %if.else188

if.then153:                                       ; preds = %if.else150
  store i8 120, i8* %ch155, align 1
  %83 = load i32* %argn, align 4
  %inc156 = add nsw i32 %83, 1
  store i32 %inc156, i32* %argn, align 4
  %84 = load i32* %argc.addr, align 4
  %cmp157 = icmp sge i32 %inc156, %84
  br i1 %cmp157, label %if.then159, label %if.end160

if.then159:                                       ; preds = %if.then153
  call void @usage()
  br label %if.end160

if.end160:                                        ; preds = %if.then159, %if.then153
  %85 = load i32* %argn, align 4
  %idxprom161 = sext i32 %85 to i64
  %86 = load i8*** %argv.addr, align 8
  %arrayidx162 = getelementptr inbounds i8** %86, i64 %idxprom161
  %87 = load i8** %arrayidx162, align 8
  %call163 = call i32 (i8*, i8*, ...)* @sscanf(i8* %87, i8* getelementptr inbounds ([6 x i8]* @.str45, i32 0, i32 0), i64* %lval154, i8* %ch155)
  %cmp164 = icmp slt i32 %call163, 1
  br i1 %cmp164, label %if.then166, label %if.end167

if.then166:                                       ; preds = %if.end160
  call void @usage()
  br label %if.end167

if.end167:                                        ; preds = %if.then166, %if.end160
  %88 = load i64* %lval154, align 8
  %cmp168 = icmp slt i64 %88, 0
  br i1 %cmp168, label %if.then173, label %lor.lhs.false170

lor.lhs.false170:                                 ; preds = %if.end167
  %89 = load i64* %lval154, align 8
  %cmp171 = icmp sgt i64 %89, 65535
  br i1 %cmp171, label %if.then173, label %if.end174

if.then173:                                       ; preds = %lor.lhs.false170, %if.end167
  call void @usage()
  br label %if.end174

if.end174:                                        ; preds = %if.then173, %lor.lhs.false170
  %90 = load i8* %ch155, align 1
  %conv175 = sext i8 %90 to i32
  %cmp176 = icmp eq i32 %conv175, 98
  br i1 %cmp176, label %if.then182, label %lor.lhs.false178

lor.lhs.false178:                                 ; preds = %if.end174
  %91 = load i8* %ch155, align 1
  %conv179 = sext i8 %91 to i32
  %cmp180 = icmp eq i32 %conv179, 66
  br i1 %cmp180, label %if.then182, label %if.else184

if.then182:                                       ; preds = %lor.lhs.false178, %if.end174
  %92 = load i64* %lval154, align 8
  %conv183 = trunc i64 %92 to i32
  %93 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %restart_interval = getelementptr inbounds %struct.jpeg_compress_struct* %93, i32 0, i32 29
  store i32 %conv183, i32* %restart_interval, align 4
  %94 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %restart_in_rows = getelementptr inbounds %struct.jpeg_compress_struct* %94, i32 0, i32 30
  store i32 0, i32* %restart_in_rows, align 4
  br label %if.end187

if.else184:                                       ; preds = %lor.lhs.false178
  %95 = load i64* %lval154, align 8
  %conv185 = trunc i64 %95 to i32
  %96 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %restart_in_rows186 = getelementptr inbounds %struct.jpeg_compress_struct* %96, i32 0, i32 30
  store i32 %conv185, i32* %restart_in_rows186, align 4
  br label %if.end187

if.end187:                                        ; preds = %if.else184, %if.then182
  br label %if.end242

if.else188:                                       ; preds = %if.else150
  %97 = load i8** %arg, align 8
  %call189 = call i32 @keymatch(i8* %97, i8* getelementptr inbounds ([7 x i8]* @.str55, i32 0, i32 0), i32 2)
  %tobool190 = icmp ne i32 %call189, 0
  br i1 %tobool190, label %if.then191, label %if.else199

if.then191:                                       ; preds = %if.else188
  %98 = load i32* %argn, align 4
  %inc192 = add nsw i32 %98, 1
  store i32 %inc192, i32* %argn, align 4
  %99 = load i32* %argc.addr, align 4
  %cmp193 = icmp sge i32 %inc192, %99
  br i1 %cmp193, label %if.then195, label %if.end196

if.then195:                                       ; preds = %if.then191
  call void @usage()
  br label %if.end196

if.end196:                                        ; preds = %if.then195, %if.then191
  %100 = load i32* %argn, align 4
  %idxprom197 = sext i32 %100 to i64
  %101 = load i8*** %argv.addr, align 8
  %arrayidx198 = getelementptr inbounds i8** %101, i64 %idxprom197
  %102 = load i8** %arrayidx198, align 8
  store i8* %102, i8** %samplearg, align 8
  br label %if.end241

if.else199:                                       ; preds = %if.else188
  %103 = load i8** %arg, align 8
  %call200 = call i32 @keymatch(i8* %103, i8* getelementptr inbounds ([6 x i8]* @.str56, i32 0, i32 0), i32 2)
  %tobool201 = icmp ne i32 %call200, 0
  br i1 %tobool201, label %if.then202, label %if.else210

if.then202:                                       ; preds = %if.else199
  %104 = load i32* %argn, align 4
  %inc203 = add nsw i32 %104, 1
  store i32 %inc203, i32* %argn, align 4
  %105 = load i32* %argc.addr, align 4
  %cmp204 = icmp sge i32 %inc203, %105
  br i1 %cmp204, label %if.then206, label %if.end207

if.then206:                                       ; preds = %if.then202
  call void @usage()
  br label %if.end207

if.end207:                                        ; preds = %if.then206, %if.then202
  %106 = load i32* %argn, align 4
  %idxprom208 = sext i32 %106 to i64
  %107 = load i8*** %argv.addr, align 8
  %arrayidx209 = getelementptr inbounds i8** %107, i64 %idxprom208
  %108 = load i8** %arrayidx209, align 8
  store i8* %108, i8** %scansarg, align 8
  br label %if.end240

if.else210:                                       ; preds = %if.else199
  %109 = load i8** %arg, align 8
  %call211 = call i32 @keymatch(i8* %109, i8* getelementptr inbounds ([7 x i8]* @.str57, i32 0, i32 0), i32 2)
  %tobool212 = icmp ne i32 %call211, 0
  br i1 %tobool212, label %if.then213, label %if.else233

if.then213:                                       ; preds = %if.else210
  %110 = load i32* %argn, align 4
  %inc214 = add nsw i32 %110, 1
  store i32 %inc214, i32* %argn, align 4
  %111 = load i32* %argc.addr, align 4
  %cmp215 = icmp sge i32 %inc214, %111
  br i1 %cmp215, label %if.then217, label %if.end218

if.then217:                                       ; preds = %if.then213
  call void @usage()
  br label %if.end218

if.end218:                                        ; preds = %if.then217, %if.then213
  %112 = load i32* %argn, align 4
  %idxprom219 = sext i32 %112 to i64
  %113 = load i8*** %argv.addr, align 8
  %arrayidx220 = getelementptr inbounds i8** %113, i64 %idxprom219
  %114 = load i8** %arrayidx220, align 8
  %call221 = call i32 (i8*, i8*, ...)* @sscanf(i8* %114, i8* getelementptr inbounds ([3 x i8]* @.str51, i32 0, i32 0), i32* %val)
  %cmp222 = icmp ne i32 %call221, 1
  br i1 %cmp222, label %if.then224, label %if.end225

if.then224:                                       ; preds = %if.end218
  call void @usage()
  br label %if.end225

if.end225:                                        ; preds = %if.then224, %if.end218
  %115 = load i32* %val, align 4
  %cmp226 = icmp slt i32 %115, 0
  br i1 %cmp226, label %if.then231, label %lor.lhs.false228

lor.lhs.false228:                                 ; preds = %if.end225
  %116 = load i32* %val, align 4
  %cmp229 = icmp sgt i32 %116, 100
  br i1 %cmp229, label %if.then231, label %if.end232

if.then231:                                       ; preds = %lor.lhs.false228, %if.end225
  call void @usage()
  br label %if.end232

if.end232:                                        ; preds = %if.then231, %lor.lhs.false228
  %117 = load i32* %val, align 4
  %118 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %smoothing_factor = getelementptr inbounds %struct.jpeg_compress_struct* %118, i32 0, i32 27
  store i32 %117, i32* %smoothing_factor, align 4
  br label %if.end239

if.else233:                                       ; preds = %if.else210
  %119 = load i8** %arg, align 8
  %call234 = call i32 @keymatch(i8* %119, i8* getelementptr inbounds ([6 x i8]* @.str58, i32 0, i32 0), i32 1)
  %tobool235 = icmp ne i32 %call234, 0
  br i1 %tobool235, label %if.then236, label %if.else237

if.then236:                                       ; preds = %if.else233
  store i32 1, i32* @is_targa, align 4
  br label %if.end238

if.else237:                                       ; preds = %if.else233
  call void @usage()
  br label %if.end238

if.end238:                                        ; preds = %if.else237, %if.then236
  br label %if.end239

if.end239:                                        ; preds = %if.end238, %if.end232
  br label %if.end240

if.end240:                                        ; preds = %if.end239, %if.end207
  br label %if.end241

if.end241:                                        ; preds = %if.end240, %if.end196
  br label %if.end242

if.end242:                                        ; preds = %if.end241, %if.end187
  br label %if.end243

if.end243:                                        ; preds = %if.end242, %if.end147
  br label %if.end244

if.end244:                                        ; preds = %if.end243, %if.end136
  br label %if.end245

if.end245:                                        ; preds = %if.end244, %if.end126
  br label %if.end246

if.end246:                                        ; preds = %if.end245, %if.then110
  br label %if.end247

if.end247:                                        ; preds = %if.end246, %if.end104
  br label %if.end248

if.end248:                                        ; preds = %if.end247, %if.then95
  br label %if.end249

if.end249:                                        ; preds = %if.end248, %if.end87
  br label %if.end250

if.end250:                                        ; preds = %if.end249, %if.then62
  br label %if.end251

if.end251:                                        ; preds = %if.end250, %if.end52
  br label %if.end252

if.end252:                                        ; preds = %if.end251, %if.end42
  br label %if.end253

if.end253:                                        ; preds = %if.end252, %if.then11
  br label %if.end254

if.end254:                                        ; preds = %if.end253
  br label %for.inc

for.inc:                                          ; preds = %if.end254, %if.then5
  %120 = load i32* %argn, align 4
  %inc255 = add nsw i32 %120, 1
  store i32 %inc255, i32* %argn, align 4
  br label %for.cond

for.end:                                          ; preds = %if.end, %for.cond
  %121 = load i32* %for_real.addr, align 4
  %tobool256 = icmp ne i32 %121, 0
  br i1 %tobool256, label %if.then257, label %if.end293

if.then257:                                       ; preds = %for.end
  %122 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %123 = load i32* %quality, align 4
  %124 = load i32* %force_baseline, align 4
  call void @jpeg_set_quality(%struct.jpeg_compress_struct* %122, i32 %123, i32 %124)
  %125 = load i8** %qtablefile, align 8
  %cmp258 = icmp ne i8* %125, null
  br i1 %cmp258, label %if.then260, label %if.end265

if.then260:                                       ; preds = %if.then257
  %126 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %127 = load i8** %qtablefile, align 8
  %128 = load i32* %q_scale_factor, align 4
  %129 = load i32* %force_baseline, align 4
  %call261 = call i32 @read_quant_tables(%struct.jpeg_compress_struct* %126, i8* %127, i32 %128, i32 %129)
  %tobool262 = icmp ne i32 %call261, 0
  br i1 %tobool262, label %if.end264, label %if.then263

if.then263:                                       ; preds = %if.then260
  call void @usage()
  br label %if.end264

if.end264:                                        ; preds = %if.then263, %if.then260
  br label %if.end265

if.end265:                                        ; preds = %if.end264, %if.then257
  %130 = load i8** %qslotsarg, align 8
  %cmp266 = icmp ne i8* %130, null
  br i1 %cmp266, label %if.then268, label %if.end273

if.then268:                                       ; preds = %if.end265
  %131 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %132 = load i8** %qslotsarg, align 8
  %call269 = call i32 @set_quant_slots(%struct.jpeg_compress_struct* %131, i8* %132)
  %tobool270 = icmp ne i32 %call269, 0
  br i1 %tobool270, label %if.end272, label %if.then271

if.then271:                                       ; preds = %if.then268
  call void @usage()
  br label %if.end272

if.end272:                                        ; preds = %if.then271, %if.then268
  br label %if.end273

if.end273:                                        ; preds = %if.end272, %if.end265
  %133 = load i8** %samplearg, align 8
  %cmp274 = icmp ne i8* %133, null
  br i1 %cmp274, label %if.then276, label %if.end281

if.then276:                                       ; preds = %if.end273
  %134 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %135 = load i8** %samplearg, align 8
  %call277 = call i32 @set_sample_factors(%struct.jpeg_compress_struct* %134, i8* %135)
  %tobool278 = icmp ne i32 %call277, 0
  br i1 %tobool278, label %if.end280, label %if.then279

if.then279:                                       ; preds = %if.then276
  call void @usage()
  br label %if.end280

if.end280:                                        ; preds = %if.then279, %if.then276
  br label %if.end281

if.end281:                                        ; preds = %if.end280, %if.end273
  %136 = load i32* %simple_progressive, align 4
  %tobool282 = icmp ne i32 %136, 0
  br i1 %tobool282, label %if.then283, label %if.end284

if.then283:                                       ; preds = %if.end281
  %137 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  call void @jpeg_simple_progression(%struct.jpeg_compress_struct* %137)
  br label %if.end284

if.end284:                                        ; preds = %if.then283, %if.end281
  %138 = load i8** %scansarg, align 8
  %cmp285 = icmp ne i8* %138, null
  br i1 %cmp285, label %if.then287, label %if.end292

if.then287:                                       ; preds = %if.end284
  %139 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %140 = load i8** %scansarg, align 8
  %call288 = call i32 @read_scan_script(%struct.jpeg_compress_struct* %139, i8* %140)
  %tobool289 = icmp ne i32 %call288, 0
  br i1 %tobool289, label %if.end291, label %if.then290

if.then290:                                       ; preds = %if.then287
  call void @usage()
  br label %if.end291

if.end291:                                        ; preds = %if.then290, %if.then287
  br label %if.end292

if.end292:                                        ; preds = %if.end291, %if.end284
  br label %if.end293

if.end293:                                        ; preds = %if.end292, %for.end
  %141 = load i32* %argn, align 4
  ret i32 %141
}

declare i32 @fprintf(%struct.__sFILE*, i8*, ...) #1

; Function Attrs: nounwind ssp uwtable
define internal void @usage() #0 {
entry:
  %0 = load %struct.__sFILE** @__stderrp, align 8
  %1 = load i8** @progname, align 8
  %call = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %0, i8* getelementptr inbounds ([22 x i8]* @.str5, i32 0, i32 0), i8* %1)
  %2 = load %struct.__sFILE** @__stderrp, align 8
  %call1 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %2, i8* getelementptr inbounds ([13 x i8]* @.str6, i32 0, i32 0))
  %3 = load %struct.__sFILE** @__stderrp, align 8
  %call2 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %3, i8* getelementptr inbounds ([38 x i8]* @.str7, i32 0, i32 0))
  %4 = load %struct.__sFILE** @__stderrp, align 8
  %call3 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %4, i8* getelementptr inbounds ([69 x i8]* @.str8, i32 0, i32 0))
  %5 = load %struct.__sFILE** @__stderrp, align 8
  %call4 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %5, i8* getelementptr inbounds ([46 x i8]* @.str9, i32 0, i32 0))
  %6 = load %struct.__sFILE** @__stderrp, align 8
  %call5 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %6, i8* getelementptr inbounds ([78 x i8]* @.str10, i32 0, i32 0))
  %7 = load %struct.__sFILE** @__stderrp, align 8
  %call6 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %7, i8* getelementptr inbounds ([47 x i8]* @.str11, i32 0, i32 0))
  %8 = load %struct.__sFILE** @__stderrp, align 8
  %call7 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %8, i8* getelementptr inbounds ([66 x i8]* @.str12, i32 0, i32 0))
  %9 = load %struct.__sFILE** @__stderrp, align 8
  %call8 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %9, i8* getelementptr inbounds ([30 x i8]* @.str13, i32 0, i32 0))
  %10 = load %struct.__sFILE** @__stderrp, align 8
  %call9 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %10, i8* getelementptr inbounds ([43 x i8]* @.str14, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8]* @.str15, i32 0, i32 0))
  %11 = load %struct.__sFILE** @__stderrp, align 8
  %call10 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %11, i8* getelementptr inbounds ([57 x i8]* @.str16, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8]* @.str17, i32 0, i32 0))
  %12 = load %struct.__sFILE** @__stderrp, align 8
  %call11 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %12, i8* getelementptr inbounds ([50 x i8]* @.str18, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8]* @.str17, i32 0, i32 0))
  %13 = load %struct.__sFILE** @__stderrp, align 8
  %call12 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %13, i8* getelementptr inbounds ([68 x i8]* @.str19, i32 0, i32 0))
  %14 = load %struct.__sFILE** @__stderrp, align 8
  %call13 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %14, i8* getelementptr inbounds ([63 x i8]* @.str20, i32 0, i32 0))
  %15 = load %struct.__sFILE** @__stderrp, align 8
  %call14 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %15, i8* getelementptr inbounds ([52 x i8]* @.str21, i32 0, i32 0))
  %16 = load %struct.__sFILE** @__stderrp, align 8
  %call15 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %16, i8* getelementptr inbounds ([47 x i8]* @.str22, i32 0, i32 0))
  %17 = load %struct.__sFILE** @__stderrp, align 8
  %call16 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %17, i8* getelementptr inbounds ([44 x i8]* @.str23, i32 0, i32 0))
  %18 = load %struct.__sFILE** @__stderrp, align 8
  %call17 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %18, i8* getelementptr inbounds ([23 x i8]* @.str24, i32 0, i32 0))
  %19 = load %struct.__sFILE** @__stderrp, align 8
  %call18 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %19, i8* getelementptr inbounds ([40 x i8]* @.str25, i32 0, i32 0))
  %20 = load %struct.__sFILE** @__stderrp, align 8
  %call19 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %20, i8* getelementptr inbounds ([56 x i8]* @.str26, i32 0, i32 0))
  %21 = load %struct.__sFILE** @__stderrp, align 8
  %call20 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %21, i8* getelementptr inbounds ([56 x i8]* @.str27, i32 0, i32 0))
  %22 = load %struct.__sFILE** @__stderrp, align 8
  %call21 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %22, i8* getelementptr inbounds ([53 x i8]* @.str28, i32 0, i32 0))
  %23 = load %struct.__sFILE** @__stderrp, align 8
  %call22 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %23, i8* getelementptr inbounds ([57 x i8]* @.str29, i32 0, i32 0))
  call void @exit(i32 1) #3
  unreachable

return:                                           ; No predecessors!
  ret void
}

declare %struct.__sFILE* @"\01_fopen"(i8*, i8*) #1

; Function Attrs: noreturn
declare void @exit(i32) #2

declare %struct.__sFILE* @read_stdin() #1

declare %struct.__sFILE* @write_stdout() #1

; Function Attrs: nounwind ssp uwtable
define internal %struct.cjpeg_source_struct* @select_file_type(%struct.jpeg_compress_struct* %cinfo, %struct.__sFILE* %infile) #0 {
entry:
  %retval = alloca %struct.cjpeg_source_struct*, align 8
  %cinfo.addr = alloca %struct.jpeg_compress_struct*, align 8
  %infile.addr = alloca %struct.__sFILE*, align 8
  %c = alloca i32, align 4
  store %struct.jpeg_compress_struct* %cinfo, %struct.jpeg_compress_struct** %cinfo.addr, align 8
  store %struct.__sFILE* %infile, %struct.__sFILE** %infile.addr, align 8
  %0 = load i32* @is_targa, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %call = call %struct.cjpeg_source_struct* @jinit_read_targa(%struct.jpeg_compress_struct* %1)
  store %struct.cjpeg_source_struct* %call, %struct.cjpeg_source_struct** %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.__sFILE** %infile.addr, align 8
  %call1 = call i32 @getc(%struct.__sFILE* %2)
  store i32 %call1, i32* %c, align 4
  %cmp = icmp eq i32 %call1, -1
  br i1 %cmp, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %3 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %err = getelementptr inbounds %struct.jpeg_compress_struct* %3, i32 0, i32 0
  %4 = load %struct.jpeg_error_mgr** %err, align 8
  %msg_code = getelementptr inbounds %struct.jpeg_error_mgr* %4, i32 0, i32 5
  store i32 41, i32* %msg_code, align 4
  %5 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %err3 = getelementptr inbounds %struct.jpeg_compress_struct* %5, i32 0, i32 0
  %6 = load %struct.jpeg_error_mgr** %err3, align 8
  %error_exit = getelementptr inbounds %struct.jpeg_error_mgr* %6, i32 0, i32 0
  %7 = load void (%struct.jpeg_common_struct*)** %error_exit, align 8
  %8 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %9 = bitcast %struct.jpeg_compress_struct* %8 to %struct.jpeg_common_struct*
  call void %7(%struct.jpeg_common_struct* %9)
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %10 = load i32* %c, align 4
  %11 = load %struct.__sFILE** %infile.addr, align 8
  %call5 = call i32 @ungetc(i32 %10, %struct.__sFILE* %11)
  %cmp6 = icmp eq i32 %call5, -1
  br i1 %cmp6, label %if.then7, label %if.end12

if.then7:                                         ; preds = %if.end4
  %12 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %err8 = getelementptr inbounds %struct.jpeg_compress_struct* %12, i32 0, i32 0
  %13 = load %struct.jpeg_error_mgr** %err8, align 8
  %msg_code9 = getelementptr inbounds %struct.jpeg_error_mgr* %13, i32 0, i32 5
  store i32 1040, i32* %msg_code9, align 4
  %14 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %err10 = getelementptr inbounds %struct.jpeg_compress_struct* %14, i32 0, i32 0
  %15 = load %struct.jpeg_error_mgr** %err10, align 8
  %error_exit11 = getelementptr inbounds %struct.jpeg_error_mgr* %15, i32 0, i32 0
  %16 = load void (%struct.jpeg_common_struct*)** %error_exit11, align 8
  %17 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %18 = bitcast %struct.jpeg_compress_struct* %17 to %struct.jpeg_common_struct*
  call void %16(%struct.jpeg_common_struct* %18)
  br label %if.end12

if.end12:                                         ; preds = %if.then7, %if.end4
  %19 = load i32* %c, align 4
  switch i32 %19, label %sw.default [
    i32 66, label %sw.bb
    i32 71, label %sw.bb14
    i32 80, label %sw.bb16
    i32 0, label %sw.bb18
  ]

sw.bb:                                            ; preds = %if.end12
  %20 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %call13 = call %struct.cjpeg_source_struct* @jinit_read_bmp(%struct.jpeg_compress_struct* %20)
  store %struct.cjpeg_source_struct* %call13, %struct.cjpeg_source_struct** %retval
  br label %return

sw.bb14:                                          ; preds = %if.end12
  %21 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %call15 = call %struct.cjpeg_source_struct* @jinit_read_gif(%struct.jpeg_compress_struct* %21)
  store %struct.cjpeg_source_struct* %call15, %struct.cjpeg_source_struct** %retval
  br label %return

sw.bb16:                                          ; preds = %if.end12
  %22 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %call17 = call %struct.cjpeg_source_struct* @jinit_read_ppm(%struct.jpeg_compress_struct* %22)
  store %struct.cjpeg_source_struct* %call17, %struct.cjpeg_source_struct** %retval
  br label %return

sw.bb18:                                          ; preds = %if.end12
  %23 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %call19 = call %struct.cjpeg_source_struct* @jinit_read_targa(%struct.jpeg_compress_struct* %23)
  store %struct.cjpeg_source_struct* %call19, %struct.cjpeg_source_struct** %retval
  br label %return

sw.default:                                       ; preds = %if.end12
  %24 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %err20 = getelementptr inbounds %struct.jpeg_compress_struct* %24, i32 0, i32 0
  %25 = load %struct.jpeg_error_mgr** %err20, align 8
  %msg_code21 = getelementptr inbounds %struct.jpeg_error_mgr* %25, i32 0, i32 5
  store i32 1041, i32* %msg_code21, align 4
  %26 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %err22 = getelementptr inbounds %struct.jpeg_compress_struct* %26, i32 0, i32 0
  %27 = load %struct.jpeg_error_mgr** %err22, align 8
  %error_exit23 = getelementptr inbounds %struct.jpeg_error_mgr* %27, i32 0, i32 0
  %28 = load void (%struct.jpeg_common_struct*)** %error_exit23, align 8
  %29 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %30 = bitcast %struct.jpeg_compress_struct* %29 to %struct.jpeg_common_struct*
  call void %28(%struct.jpeg_common_struct* %30)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default
  store %struct.cjpeg_source_struct* null, %struct.cjpeg_source_struct** %retval
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb18, %sw.bb16, %sw.bb14, %sw.bb, %if.then
  %31 = load %struct.cjpeg_source_struct** %retval
  ret %struct.cjpeg_source_struct* %31
}

declare void @jpeg_default_colorspace(%struct.jpeg_compress_struct*) #1

declare void @jpeg_stdio_dest(%struct.jpeg_compress_struct*, %struct.__sFILE*) #1

declare void @jpeg_start_compress(%struct.jpeg_compress_struct*, i32) #1

declare i32 @jpeg_write_scanlines(%struct.jpeg_compress_struct*, i8**, i32) #1

declare void @jpeg_finish_compress(%struct.jpeg_compress_struct*) #1

declare void @jpeg_destroy_compress(%struct.jpeg_compress_struct*) #1

declare i32 @fclose(%struct.__sFILE*) #1

declare %struct.cjpeg_source_struct* @jinit_read_targa(%struct.jpeg_compress_struct*) #1

declare i32 @getc(%struct.__sFILE*) #1

declare i32 @ungetc(i32, %struct.__sFILE*) #1

declare %struct.cjpeg_source_struct* @jinit_read_bmp(%struct.jpeg_compress_struct*) #1

declare %struct.cjpeg_source_struct* @jinit_read_gif(%struct.jpeg_compress_struct*) #1

declare %struct.cjpeg_source_struct* @jinit_read_ppm(%struct.jpeg_compress_struct*) #1

declare i32 @keymatch(i8*, i8*, i32) #1

declare void @jpeg_set_colorspace(%struct.jpeg_compress_struct*, i32) #1

declare i32 @sscanf(i8*, i8*, ...) #1

declare i32 @jpeg_quality_scaling(i32) #1

declare void @jpeg_set_quality(%struct.jpeg_compress_struct*, i32, i32) #1

declare i32 @read_quant_tables(%struct.jpeg_compress_struct*, i8*, i32, i32) #1

declare i32 @set_quant_slots(%struct.jpeg_compress_struct*, i8*) #1

declare i32 @set_sample_factors(%struct.jpeg_compress_struct*, i8*) #1

declare void @jpeg_simple_progression(%struct.jpeg_compress_struct*) #1

declare i32 @read_scan_script(%struct.jpeg_compress_struct*, i8*) #1

attributes #0 = { nounwind ssp uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { noreturn }
