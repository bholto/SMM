; ModuleID = 'wrjpgcom.c'
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-apple-macosx10.9.0"

%struct.__sFILE = type { i8*, i32, i32, i16, i16, %struct.__sbuf, i32, i8*, i32 (i8*)*, i32 (i8*, i8*, i32)*, i64 (i8*, i64, i32)*, i32 (i8*, i8*, i32)*, %struct.__sbuf, %struct.__sFILEX*, i32, [3 x i8], [1 x i8], %struct.__sbuf, i32, i64 }
%struct.__sbuf = type { i8*, i32 }
%struct.__sFILEX = type opaque

@progname = internal global i8* null, align 8
@.str = private unnamed_addr constant [9 x i8] c"wrjpgcom\00", align 1
@.str1 = private unnamed_addr constant [8 x i8] c"replace\00", align 1
@.str2 = private unnamed_addr constant [6 x i8] c"cfile\00", align 1
@.str3 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@__stderrp = external global %struct.__sFILE*
@.str4 = private unnamed_addr constant [19 x i8] c"%s: can't open %s\0A\00", align 1
@.str5 = private unnamed_addr constant [8 x i8] c"comment\00", align 1
@.str6 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@.str7 = private unnamed_addr constant [20 x i8] c"Insufficient memory\00", align 1
@.str8 = private unnamed_addr constant [26 x i8] c"Missing ending quote mark\00", align 1
@.str9 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str10 = private unnamed_addr constant [3 x i8] c"rb\00", align 1
@infile = internal global %struct.__sFILE* null, align 8
@__stdinp = external global %struct.__sFILE*
@.str11 = private unnamed_addr constant [25 x i8] c"%s: only one input file\0A\00", align 1
@__stdoutp = external global %struct.__sFILE*
@outfile = internal global %struct.__sFILE* null, align 8
@.str12 = private unnamed_addr constant [38 x i8] c"Comment text may not exceed %u bytes\0A\00", align 1
@.str13 = private unnamed_addr constant [26 x i8] c"Expected SOI marker first\00", align 1
@.str14 = private unnamed_addr constant [23 x i8] c"SOS without prior SOFn\00", align 1
@.str15 = private unnamed_addr constant [29 x i8] c"Erroneous JPEG marker length\00", align 1
@.str16 = private unnamed_addr constant [27 x i8] c"Premature EOF in JPEG file\00", align 1
@.str17 = private unnamed_addr constant [42 x i8] c"Warning: garbage data found in JPEG file\0A\00", align 1
@.str18 = private unnamed_addr constant [16 x i8] c"Not a JPEG file\00", align 1
@.str19 = private unnamed_addr constant [52 x i8] c"wrjpgcom inserts a textual comment in a JPEG file.\0A\00", align 1
@.str20 = private unnamed_addr constant [52 x i8] c"You can add to or replace any existing comment(s).\0A\00", align 1
@.str21 = private unnamed_addr constant [22 x i8] c"Usage: %s [switches] \00", align 1
@.str22 = private unnamed_addr constant [13 x i8] c"[inputfile]\0A\00", align 1
@.str23 = private unnamed_addr constant [38 x i8] c"Switches (names may be abbreviated):\0A\00", align 1
@.str24 = private unnamed_addr constant [49 x i8] c"  -replace         Delete any existing comments\0A\00", align 1
@.str25 = private unnamed_addr constant [51 x i8] c"  -comment \22text\22  Insert comment with given text\0A\00", align 1
@.str26 = private unnamed_addr constant [49 x i8] c"  -cfile name      Read comment from named file\0A\00", align 1
@.str27 = private unnamed_addr constant [57 x i8] c"Notice that you must put quotes around the comment text\0A\00", align 1
@.str28 = private unnamed_addr constant [24 x i8] c"when you use -comment.\0A\00", align 1
@.str29 = private unnamed_addr constant [67 x i8] c"If you do not give either -comment or -cfile on the command line,\0A\00", align 1
@.str30 = private unnamed_addr constant [52 x i8] c"then the comment text is read from standard input.\0A\00", align 1
@.str31 = private unnamed_addr constant [54 x i8] c"It can be multiple lines, up to %u characters total.\0A\00", align 1
@.str32 = private unnamed_addr constant [57 x i8] c"You must specify an input JPEG file name when supplying\0A\00", align 1
@.str33 = private unnamed_addr constant [35 x i8] c"comment text from standard input.\0A\00", align 1

; Function Attrs: nounwind ssp uwtable
define i32 @main(i32 %argc, i8** %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  %argn = alloca i32, align 4
  %arg = alloca i8*, align 8
  %keep_COM = alloca i32, align 4
  %comment_arg = alloca i8*, align 8
  %comment_file = alloca %struct.__sFILE*, align 8
  %comment_length = alloca i32, align 4
  %marker = alloca i32, align 4
  %src_file = alloca %struct.__sFILE*, align 8
  %c = alloca i32, align 4
  store i32 0, i32* %retval
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  store i32 1, i32* %keep_COM, align 4
  store i8* null, i8** %comment_arg, align 8
  store %struct.__sFILE* null, %struct.__sFILE** %comment_file, align 8
  store i32 0, i32* %comment_length, align 4
  %0 = load i8*** %argv.addr, align 8
  %arrayidx = getelementptr inbounds i8** %0, i64 0
  %1 = load i8** %arrayidx, align 8
  store i8* %1, i8** @progname, align 8
  %2 = load i8** @progname, align 8
  %cmp = icmp eq i8* %2, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load i8** @progname, align 8
  %arrayidx1 = getelementptr inbounds i8* %3, i64 0
  %4 = load i8* %arrayidx1, align 1
  %conv = sext i8 %4 to i32
  %cmp2 = icmp eq i32 %conv, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i8* getelementptr inbounds ([9 x i8]* @.str, i32 0, i32 0), i8** @progname, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  store i32 1, i32* %argn, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %5 = load i32* %argn, align 4
  %6 = load i32* %argc.addr, align 4
  %cmp4 = icmp slt i32 %5, %6
  br i1 %cmp4, label %for.body, label %for.end89

for.body:                                         ; preds = %for.cond
  %7 = load i32* %argn, align 4
  %idxprom = sext i32 %7 to i64
  %8 = load i8*** %argv.addr, align 8
  %arrayidx6 = getelementptr inbounds i8** %8, i64 %idxprom
  %9 = load i8** %arrayidx6, align 8
  store i8* %9, i8** %arg, align 8
  %10 = load i8** %arg, align 8
  %arrayidx7 = getelementptr inbounds i8* %10, i64 0
  %11 = load i8* %arrayidx7, align 1
  %conv8 = sext i8 %11 to i32
  %cmp9 = icmp ne i32 %conv8, 45
  br i1 %cmp9, label %if.then11, label %if.end12

if.then11:                                        ; preds = %for.body
  br label %for.end89

if.end12:                                         ; preds = %for.body
  %12 = load i8** %arg, align 8
  %incdec.ptr = getelementptr inbounds i8* %12, i32 1
  store i8* %incdec.ptr, i8** %arg, align 8
  %13 = load i8** %arg, align 8
  %call = call i32 @keymatch(i8* %13, i8* getelementptr inbounds ([8 x i8]* @.str1, i32 0, i32 0), i32 1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then13, label %if.else

if.then13:                                        ; preds = %if.end12
  store i32 0, i32* %keep_COM, align 4
  br label %if.end87

if.else:                                          ; preds = %if.end12
  %14 = load i8** %arg, align 8
  %call14 = call i32 @keymatch(i8* %14, i8* getelementptr inbounds ([6 x i8]* @.str2, i32 0, i32 0), i32 2)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %if.then16, label %if.else31

if.then16:                                        ; preds = %if.else
  %15 = load i32* %argn, align 4
  %inc = add nsw i32 %15, 1
  store i32 %inc, i32* %argn, align 4
  %16 = load i32* %argc.addr, align 4
  %cmp17 = icmp sge i32 %inc, %16
  br i1 %cmp17, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.then16
  call void @usage()
  br label %if.end20

if.end20:                                         ; preds = %if.then19, %if.then16
  %17 = load i32* %argn, align 4
  %idxprom21 = sext i32 %17 to i64
  %18 = load i8*** %argv.addr, align 8
  %arrayidx22 = getelementptr inbounds i8** %18, i64 %idxprom21
  %19 = load i8** %arrayidx22, align 8
  %call23 = call %struct.__sFILE* @"\01_fopen"(i8* %19, i8* getelementptr inbounds ([2 x i8]* @.str3, i32 0, i32 0))
  store %struct.__sFILE* %call23, %struct.__sFILE** %comment_file, align 8
  %cmp24 = icmp eq %struct.__sFILE* %call23, null
  br i1 %cmp24, label %if.then26, label %if.end30

if.then26:                                        ; preds = %if.end20
  %20 = load %struct.__sFILE** @__stderrp, align 8
  %21 = load i8** @progname, align 8
  %22 = load i32* %argn, align 4
  %idxprom27 = sext i32 %22 to i64
  %23 = load i8*** %argv.addr, align 8
  %arrayidx28 = getelementptr inbounds i8** %23, i64 %idxprom27
  %24 = load i8** %arrayidx28, align 8
  %call29 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %20, i8* getelementptr inbounds ([19 x i8]* @.str4, i32 0, i32 0), i8* %21, i8* %24)
  call void @exit(i32 1) #5
  unreachable

if.end30:                                         ; preds = %if.end20
  br label %if.end86

if.else31:                                        ; preds = %if.else
  %25 = load i8** %arg, align 8
  %call32 = call i32 @keymatch(i8* %25, i8* getelementptr inbounds ([8 x i8]* @.str5, i32 0, i32 0), i32 1)
  %tobool33 = icmp ne i32 %call32, 0
  br i1 %tobool33, label %if.then34, label %if.else84

if.then34:                                        ; preds = %if.else31
  %26 = load i32* %argn, align 4
  %inc35 = add nsw i32 %26, 1
  store i32 %inc35, i32* %argn, align 4
  %27 = load i32* %argc.addr, align 4
  %cmp36 = icmp sge i32 %inc35, %27
  br i1 %cmp36, label %if.then38, label %if.end39

if.then38:                                        ; preds = %if.then34
  call void @usage()
  br label %if.end39

if.end39:                                         ; preds = %if.then38, %if.then34
  %28 = load i32* %argn, align 4
  %idxprom40 = sext i32 %28 to i64
  %29 = load i8*** %argv.addr, align 8
  %arrayidx41 = getelementptr inbounds i8** %29, i64 %idxprom40
  %30 = load i8** %arrayidx41, align 8
  store i8* %30, i8** %comment_arg, align 8
  %31 = load i8** %comment_arg, align 8
  %arrayidx42 = getelementptr inbounds i8* %31, i64 0
  %32 = load i8* %arrayidx42, align 1
  %conv43 = sext i8 %32 to i32
  %cmp44 = icmp eq i32 %conv43, 34
  br i1 %cmp44, label %if.then46, label %if.end81

if.then46:                                        ; preds = %if.end39
  %call47 = call i8* @malloc(i64 65000)
  store i8* %call47, i8** %comment_arg, align 8
  %33 = load i8** %comment_arg, align 8
  %cmp48 = icmp eq i8* %33, null
  br i1 %cmp48, label %if.then50, label %if.end52

if.then50:                                        ; preds = %if.then46
  %34 = load %struct.__sFILE** @__stderrp, align 8
  %call51 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %34, i8* getelementptr inbounds ([4 x i8]* @.str6, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8]* @.str7, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end52:                                         ; preds = %if.then46
  %35 = load i8** %comment_arg, align 8
  %36 = load i32* %argn, align 4
  %idxprom53 = sext i32 %36 to i64
  %37 = load i8*** %argv.addr, align 8
  %arrayidx54 = getelementptr inbounds i8** %37, i64 %idxprom53
  %38 = load i8** %arrayidx54, align 8
  %add.ptr = getelementptr inbounds i8* %38, i64 1
  %39 = load i8** %comment_arg, align 8
  %40 = call i64 @llvm.objectsize.i64(i8* %39, i1 false)
  %call55 = call i8* @__strcpy_chk(i8* %35, i8* %add.ptr, i64 %40) #6
  br label %for.cond56

for.cond56:                                       ; preds = %if.end76, %if.end52
  %41 = load i8** %comment_arg, align 8
  %call57 = call i64 @strlen(i8* %41)
  %conv58 = trunc i64 %call57 to i32
  store i32 %conv58, i32* %comment_length, align 4
  %42 = load i32* %comment_length, align 4
  %cmp59 = icmp ugt i32 %42, 0
  br i1 %cmp59, label %land.lhs.true, label %if.end70

land.lhs.true:                                    ; preds = %for.cond56
  %43 = load i32* %comment_length, align 4
  %sub = sub i32 %43, 1
  %idxprom61 = zext i32 %sub to i64
  %44 = load i8** %comment_arg, align 8
  %arrayidx62 = getelementptr inbounds i8* %44, i64 %idxprom61
  %45 = load i8* %arrayidx62, align 1
  %conv63 = sext i8 %45 to i32
  %cmp64 = icmp eq i32 %conv63, 34
  br i1 %cmp64, label %if.then66, label %if.end70

if.then66:                                        ; preds = %land.lhs.true
  %46 = load i32* %comment_length, align 4
  %sub67 = sub i32 %46, 1
  %idxprom68 = zext i32 %sub67 to i64
  %47 = load i8** %comment_arg, align 8
  %arrayidx69 = getelementptr inbounds i8* %47, i64 %idxprom68
  store i8 0, i8* %arrayidx69, align 1
  br label %for.end

if.end70:                                         ; preds = %land.lhs.true, %for.cond56
  %48 = load i32* %argn, align 4
  %inc71 = add nsw i32 %48, 1
  store i32 %inc71, i32* %argn, align 4
  %49 = load i32* %argc.addr, align 4
  %cmp72 = icmp sge i32 %inc71, %49
  br i1 %cmp72, label %if.then74, label %if.end76

if.then74:                                        ; preds = %if.end70
  %50 = load %struct.__sFILE** @__stderrp, align 8
  %call75 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %50, i8* getelementptr inbounds ([4 x i8]* @.str6, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8]* @.str8, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end76:                                         ; preds = %if.end70
  %51 = load i8** %comment_arg, align 8
  %52 = load i8** %comment_arg, align 8
  %53 = call i64 @llvm.objectsize.i64(i8* %52, i1 false)
  %call77 = call i8* @__strcat_chk(i8* %51, i8* getelementptr inbounds ([2 x i8]* @.str9, i32 0, i32 0), i64 %53) #6
  %54 = load i8** %comment_arg, align 8
  %55 = load i32* %argn, align 4
  %idxprom78 = sext i32 %55 to i64
  %56 = load i8*** %argv.addr, align 8
  %arrayidx79 = getelementptr inbounds i8** %56, i64 %idxprom78
  %57 = load i8** %arrayidx79, align 8
  %58 = load i8** %comment_arg, align 8
  %59 = call i64 @llvm.objectsize.i64(i8* %58, i1 false)
  %call80 = call i8* @__strcat_chk(i8* %54, i8* %57, i64 %59) #6
  br label %for.cond56

for.end:                                          ; preds = %if.then66
  br label %if.end81

if.end81:                                         ; preds = %for.end, %if.end39
  %60 = load i8** %comment_arg, align 8
  %call82 = call i64 @strlen(i8* %60)
  %conv83 = trunc i64 %call82 to i32
  store i32 %conv83, i32* %comment_length, align 4
  br label %if.end85

if.else84:                                        ; preds = %if.else31
  call void @usage()
  br label %if.end85

if.end85:                                         ; preds = %if.else84, %if.end81
  br label %if.end86

if.end86:                                         ; preds = %if.end85, %if.end30
  br label %if.end87

if.end87:                                         ; preds = %if.end86, %if.then13
  br label %for.inc

for.inc:                                          ; preds = %if.end87
  %61 = load i32* %argn, align 4
  %inc88 = add nsw i32 %61, 1
  store i32 %inc88, i32* %argn, align 4
  br label %for.cond

for.end89:                                        ; preds = %if.then11, %for.cond
  %62 = load i8** %comment_arg, align 8
  %cmp90 = icmp ne i8* %62, null
  br i1 %cmp90, label %land.lhs.true92, label %if.end96

land.lhs.true92:                                  ; preds = %for.end89
  %63 = load %struct.__sFILE** %comment_file, align 8
  %cmp93 = icmp ne %struct.__sFILE* %63, null
  br i1 %cmp93, label %if.then95, label %if.end96

if.then95:                                        ; preds = %land.lhs.true92
  call void @usage()
  br label %if.end96

if.end96:                                         ; preds = %if.then95, %land.lhs.true92, %for.end89
  %64 = load i8** %comment_arg, align 8
  %cmp97 = icmp eq i8* %64, null
  br i1 %cmp97, label %land.lhs.true99, label %if.end106

land.lhs.true99:                                  ; preds = %if.end96
  %65 = load %struct.__sFILE** %comment_file, align 8
  %cmp100 = icmp eq %struct.__sFILE* %65, null
  br i1 %cmp100, label %land.lhs.true102, label %if.end106

land.lhs.true102:                                 ; preds = %land.lhs.true99
  %66 = load i32* %argn, align 4
  %67 = load i32* %argc.addr, align 4
  %cmp103 = icmp sge i32 %66, %67
  br i1 %cmp103, label %if.then105, label %if.end106

if.then105:                                       ; preds = %land.lhs.true102
  call void @usage()
  br label %if.end106

if.end106:                                        ; preds = %if.then105, %land.lhs.true102, %land.lhs.true99, %if.end96
  %68 = load i32* %argn, align 4
  %69 = load i32* %argc.addr, align 4
  %cmp107 = icmp slt i32 %68, %69
  br i1 %cmp107, label %if.then109, label %if.else120

if.then109:                                       ; preds = %if.end106
  %70 = load i32* %argn, align 4
  %idxprom110 = sext i32 %70 to i64
  %71 = load i8*** %argv.addr, align 8
  %arrayidx111 = getelementptr inbounds i8** %71, i64 %idxprom110
  %72 = load i8** %arrayidx111, align 8
  %call112 = call %struct.__sFILE* @"\01_fopen"(i8* %72, i8* getelementptr inbounds ([3 x i8]* @.str10, i32 0, i32 0))
  store %struct.__sFILE* %call112, %struct.__sFILE** @infile, align 8
  %cmp113 = icmp eq %struct.__sFILE* %call112, null
  br i1 %cmp113, label %if.then115, label %if.end119

if.then115:                                       ; preds = %if.then109
  %73 = load %struct.__sFILE** @__stderrp, align 8
  %74 = load i8** @progname, align 8
  %75 = load i32* %argn, align 4
  %idxprom116 = sext i32 %75 to i64
  %76 = load i8*** %argv.addr, align 8
  %arrayidx117 = getelementptr inbounds i8** %76, i64 %idxprom116
  %77 = load i8** %arrayidx117, align 8
  %call118 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %73, i8* getelementptr inbounds ([19 x i8]* @.str4, i32 0, i32 0), i8* %74, i8* %77)
  call void @exit(i32 1) #5
  unreachable

if.end119:                                        ; preds = %if.then109
  br label %if.end121

if.else120:                                       ; preds = %if.end106
  %78 = load %struct.__sFILE** @__stdinp, align 8
  store %struct.__sFILE* %78, %struct.__sFILE** @infile, align 8
  br label %if.end121

if.end121:                                        ; preds = %if.else120, %if.end119
  %79 = load i32* %argn, align 4
  %80 = load i32* %argc.addr, align 4
  %sub122 = sub nsw i32 %80, 1
  %cmp123 = icmp slt i32 %79, %sub122
  br i1 %cmp123, label %if.then125, label %if.end127

if.then125:                                       ; preds = %if.end121
  %81 = load %struct.__sFILE** @__stderrp, align 8
  %82 = load i8** @progname, align 8
  %call126 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %81, i8* getelementptr inbounds ([25 x i8]* @.str11, i32 0, i32 0), i8* %82)
  call void @usage()
  br label %if.end127

if.end127:                                        ; preds = %if.then125, %if.end121
  %83 = load %struct.__sFILE** @__stdoutp, align 8
  store %struct.__sFILE* %83, %struct.__sFILE** @outfile, align 8
  %84 = load i8** %comment_arg, align 8
  %cmp128 = icmp eq i8* %84, null
  br i1 %cmp128, label %if.then130, label %if.end156

if.then130:                                       ; preds = %if.end127
  %call131 = call i8* @malloc(i64 65000)
  store i8* %call131, i8** %comment_arg, align 8
  %85 = load i8** %comment_arg, align 8
  %cmp132 = icmp eq i8* %85, null
  br i1 %cmp132, label %if.then134, label %if.end136

if.then134:                                       ; preds = %if.then130
  %86 = load %struct.__sFILE** @__stderrp, align 8
  %call135 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %86, i8* getelementptr inbounds ([4 x i8]* @.str6, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8]* @.str7, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end136:                                        ; preds = %if.then130
  store i32 0, i32* %comment_length, align 4
  %87 = load %struct.__sFILE** %comment_file, align 8
  %cmp137 = icmp ne %struct.__sFILE* %87, null
  br i1 %cmp137, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end136
  %88 = load %struct.__sFILE** %comment_file, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end136
  %89 = load %struct.__sFILE** @__stdinp, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.__sFILE* [ %88, %cond.true ], [ %89, %cond.false ]
  store %struct.__sFILE* %cond, %struct.__sFILE** %src_file, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end146, %cond.end
  %90 = load %struct.__sFILE** %src_file, align 8
  %call139 = call i32 @getc(%struct.__sFILE* %90)
  store i32 %call139, i32* %c, align 4
  %cmp140 = icmp ne i32 %call139, -1
  br i1 %cmp140, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %91 = load i32* %comment_length, align 4
  %cmp142 = icmp uge i32 %91, 65000
  br i1 %cmp142, label %if.then144, label %if.end146

if.then144:                                       ; preds = %while.body
  %92 = load %struct.__sFILE** @__stderrp, align 8
  %call145 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %92, i8* getelementptr inbounds ([38 x i8]* @.str12, i32 0, i32 0), i32 65000)
  call void @exit(i32 1) #5
  unreachable

if.end146:                                        ; preds = %while.body
  %93 = load i32* %c, align 4
  %conv147 = trunc i32 %93 to i8
  %94 = load i32* %comment_length, align 4
  %inc148 = add i32 %94, 1
  store i32 %inc148, i32* %comment_length, align 4
  %idxprom149 = zext i32 %94 to i64
  %95 = load i8** %comment_arg, align 8
  %arrayidx150 = getelementptr inbounds i8* %95, i64 %idxprom149
  store i8 %conv147, i8* %arrayidx150, align 1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %96 = load %struct.__sFILE** %comment_file, align 8
  %cmp151 = icmp ne %struct.__sFILE* %96, null
  br i1 %cmp151, label %if.then153, label %if.end155

if.then153:                                       ; preds = %while.end
  %97 = load %struct.__sFILE** %comment_file, align 8
  %call154 = call i32 @fclose(%struct.__sFILE* %97)
  br label %if.end155

if.end155:                                        ; preds = %if.then153, %while.end
  br label %if.end156

if.end156:                                        ; preds = %if.end155, %if.end127
  %98 = load i32* %keep_COM, align 4
  %call157 = call i32 @scan_JPEG_header(i32 %98)
  store i32 %call157, i32* %marker, align 4
  %99 = load i32* %comment_length, align 4
  %cmp158 = icmp ugt i32 %99, 0
  br i1 %cmp158, label %if.then160, label %if.end168

if.then160:                                       ; preds = %if.end156
  call void @write_marker(i32 254)
  %100 = load i32* %comment_length, align 4
  %add = add i32 %100, 2
  call void @write_2_bytes(i32 %add)
  br label %while.cond161

while.cond161:                                    ; preds = %while.body164, %if.then160
  %101 = load i32* %comment_length, align 4
  %cmp162 = icmp ugt i32 %101, 0
  br i1 %cmp162, label %while.body164, label %while.end167

while.body164:                                    ; preds = %while.cond161
  %102 = load i8** %comment_arg, align 8
  %incdec.ptr165 = getelementptr inbounds i8* %102, i32 1
  store i8* %incdec.ptr165, i8** %comment_arg, align 8
  %103 = load i8* %102, align 1
  %conv166 = sext i8 %103 to i32
  call void @write_1_byte(i32 %conv166)
  %104 = load i32* %comment_length, align 4
  %dec = add i32 %104, -1
  store i32 %dec, i32* %comment_length, align 4
  br label %while.cond161

while.end167:                                     ; preds = %while.cond161
  br label %if.end168

if.end168:                                        ; preds = %while.end167, %if.end156
  %105 = load i32* %marker, align 4
  call void @write_marker(i32 %105)
  call void @copy_rest_of_file()
  call void @exit(i32 0) #5
  unreachable

return:                                           ; No predecessors!
  %106 = load i32* %retval
  ret i32 %106
}

; Function Attrs: nounwind ssp uwtable
define internal i32 @keymatch(i8* %arg, i8* %keyword, i32 %minchars) #0 {
entry:
  %retval = alloca i32, align 4
  %arg.addr = alloca i8*, align 8
  %keyword.addr = alloca i8*, align 8
  %minchars.addr = alloca i32, align 4
  %ca = alloca i32, align 4
  %ck = alloca i32, align 4
  %nmatched = alloca i32, align 4
  store i8* %arg, i8** %arg.addr, align 8
  store i8* %keyword, i8** %keyword.addr, align 8
  store i32 %minchars, i32* %minchars.addr, align 4
  store i32 0, i32* %nmatched, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end12, %entry
  %0 = load i8** %arg.addr, align 8
  %incdec.ptr = getelementptr inbounds i8* %0, i32 1
  store i8* %incdec.ptr, i8** %arg.addr, align 8
  %1 = load i8* %0, align 1
  %conv = sext i8 %1 to i32
  store i32 %conv, i32* %ca, align 4
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load i8** %keyword.addr, align 8
  %incdec.ptr2 = getelementptr inbounds i8* %2, i32 1
  store i8* %incdec.ptr2, i8** %keyword.addr, align 8
  %3 = load i8* %2, align 1
  %conv3 = sext i8 %3 to i32
  store i32 %conv3, i32* %ck, align 4
  %cmp4 = icmp eq i32 %conv3, 0
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %while.body
  %4 = load i32* %ca, align 4
  %call = call i32 @isupper(i32 %4)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end
  %5 = load i32* %ca, align 4
  %call7 = call i32 @tolower(i32 %5)
  store i32 %call7, i32* %ca, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end
  %6 = load i32* %ca, align 4
  %7 = load i32* %ck, align 4
  %cmp9 = icmp ne i32 %6, %7
  br i1 %cmp9, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end8
  store i32 0, i32* %retval
  br label %return

if.end12:                                         ; preds = %if.end8
  %8 = load i32* %nmatched, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %nmatched, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %9 = load i32* %nmatched, align 4
  %10 = load i32* %minchars.addr, align 4
  %cmp13 = icmp slt i32 %9, %10
  br i1 %cmp13, label %if.then15, label %if.end16

if.then15:                                        ; preds = %while.end
  store i32 0, i32* %retval
  br label %return

if.end16:                                         ; preds = %while.end
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end16, %if.then15, %if.then11, %if.then
  %11 = load i32* %retval
  ret i32 %11
}

; Function Attrs: nounwind ssp uwtable
define internal void @usage() #0 {
entry:
  %0 = load %struct.__sFILE** @__stderrp, align 8
  %call = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %0, i8* getelementptr inbounds ([52 x i8]* @.str19, i32 0, i32 0))
  %1 = load %struct.__sFILE** @__stderrp, align 8
  %call1 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %1, i8* getelementptr inbounds ([52 x i8]* @.str20, i32 0, i32 0))
  %2 = load %struct.__sFILE** @__stderrp, align 8
  %3 = load i8** @progname, align 8
  %call2 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %2, i8* getelementptr inbounds ([22 x i8]* @.str21, i32 0, i32 0), i8* %3)
  %4 = load %struct.__sFILE** @__stderrp, align 8
  %call3 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %4, i8* getelementptr inbounds ([13 x i8]* @.str22, i32 0, i32 0))
  %5 = load %struct.__sFILE** @__stderrp, align 8
  %call4 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %5, i8* getelementptr inbounds ([38 x i8]* @.str23, i32 0, i32 0))
  %6 = load %struct.__sFILE** @__stderrp, align 8
  %call5 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %6, i8* getelementptr inbounds ([49 x i8]* @.str24, i32 0, i32 0))
  %7 = load %struct.__sFILE** @__stderrp, align 8
  %call6 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %7, i8* getelementptr inbounds ([51 x i8]* @.str25, i32 0, i32 0))
  %8 = load %struct.__sFILE** @__stderrp, align 8
  %call7 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %8, i8* getelementptr inbounds ([49 x i8]* @.str26, i32 0, i32 0))
  %9 = load %struct.__sFILE** @__stderrp, align 8
  %call8 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %9, i8* getelementptr inbounds ([57 x i8]* @.str27, i32 0, i32 0))
  %10 = load %struct.__sFILE** @__stderrp, align 8
  %call9 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %10, i8* getelementptr inbounds ([24 x i8]* @.str28, i32 0, i32 0))
  %11 = load %struct.__sFILE** @__stderrp, align 8
  %call10 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %11, i8* getelementptr inbounds ([67 x i8]* @.str29, i32 0, i32 0))
  %12 = load %struct.__sFILE** @__stderrp, align 8
  %call11 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %12, i8* getelementptr inbounds ([52 x i8]* @.str30, i32 0, i32 0))
  %13 = load %struct.__sFILE** @__stderrp, align 8
  %call12 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %13, i8* getelementptr inbounds ([54 x i8]* @.str31, i32 0, i32 0), i32 65000)
  %14 = load %struct.__sFILE** @__stderrp, align 8
  %call13 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %14, i8* getelementptr inbounds ([57 x i8]* @.str32, i32 0, i32 0))
  %15 = load %struct.__sFILE** @__stderrp, align 8
  %call14 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %15, i8* getelementptr inbounds ([35 x i8]* @.str33, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

return:                                           ; No predecessors!
  ret void
}

declare %struct.__sFILE* @"\01_fopen"(i8*, i8*) #1

declare i32 @fprintf(%struct.__sFILE*, i8*, ...) #1

; Function Attrs: noreturn
declare void @exit(i32) #2

declare i8* @malloc(i64) #1

; Function Attrs: nounwind
declare i8* @__strcpy_chk(i8*, i8*, i64) #3

; Function Attrs: nounwind readnone
declare i64 @llvm.objectsize.i64(i8*, i1) #4

declare i64 @strlen(i8*) #1

; Function Attrs: nounwind
declare i8* @__strcat_chk(i8*, i8*, i64) #3

declare i32 @getc(%struct.__sFILE*) #1

declare i32 @fclose(%struct.__sFILE*) #1

; Function Attrs: nounwind ssp uwtable
define internal i32 @scan_JPEG_header(i32 %keep_COM) #0 {
entry:
  %retval = alloca i32, align 4
  %keep_COM.addr = alloca i32, align 4
  %marker = alloca i32, align 4
  store i32 %keep_COM, i32* %keep_COM.addr, align 4
  %call = call i32 @first_marker()
  %cmp = icmp ne i32 %call, 216
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = load %struct.__sFILE** @__stderrp, align 8
  %call1 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %0, i8* getelementptr inbounds ([4 x i8]* @.str6, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8]* @.str13, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  call void @write_marker(i32 216)
  br label %for.cond

for.cond:                                         ; preds = %sw.epilog, %if.end
  %call2 = call i32 @next_marker()
  store i32 %call2, i32* %marker, align 4
  %1 = load i32* %marker, align 4
  switch i32 %1, label %sw.default [
    i32 192, label %sw.bb
    i32 193, label %sw.bb
    i32 194, label %sw.bb
    i32 195, label %sw.bb
    i32 197, label %sw.bb
    i32 198, label %sw.bb
    i32 199, label %sw.bb
    i32 201, label %sw.bb
    i32 202, label %sw.bb
    i32 203, label %sw.bb
    i32 205, label %sw.bb
    i32 206, label %sw.bb
    i32 207, label %sw.bb
    i32 218, label %sw.bb3
    i32 217, label %sw.bb5
    i32 254, label %sw.bb6
  ]

sw.bb:                                            ; preds = %for.cond, %for.cond, %for.cond, %for.cond, %for.cond, %for.cond, %for.cond, %for.cond, %for.cond, %for.cond, %for.cond, %for.cond, %for.cond
  %2 = load i32* %marker, align 4
  store i32 %2, i32* %retval
  br label %return

sw.bb3:                                           ; preds = %for.cond
  %3 = load %struct.__sFILE** @__stderrp, align 8
  %call4 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %3, i8* getelementptr inbounds ([4 x i8]* @.str6, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8]* @.str14, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

sw.bb5:                                           ; preds = %for.cond
  %4 = load i32* %marker, align 4
  store i32 %4, i32* %retval
  br label %return

sw.bb6:                                           ; preds = %for.cond
  %5 = load i32* %keep_COM.addr, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.then7, label %if.else

if.then7:                                         ; preds = %sw.bb6
  %6 = load i32* %marker, align 4
  call void @write_marker(i32 %6)
  call void @copy_variable()
  br label %if.end8

if.else:                                          ; preds = %sw.bb6
  call void @skip_variable()
  br label %if.end8

if.end8:                                          ; preds = %if.else, %if.then7
  br label %sw.epilog

sw.default:                                       ; preds = %for.cond
  %7 = load i32* %marker, align 4
  call void @write_marker(i32 %7)
  call void @copy_variable()
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end8
  br label %for.cond

return:                                           ; preds = %sw.bb5, %sw.bb
  %8 = load i32* %retval
  ret i32 %8
}

; Function Attrs: nounwind ssp uwtable
define internal void @write_marker(i32 %marker) #0 {
entry:
  %marker.addr = alloca i32, align 4
  store i32 %marker, i32* %marker.addr, align 4
  %0 = load %struct.__sFILE** @outfile, align 8
  %call = call i32 @putc(i32 255, %struct.__sFILE* %0)
  %1 = load i32* %marker.addr, align 4
  %2 = load %struct.__sFILE** @outfile, align 8
  %call1 = call i32 @putc(i32 %1, %struct.__sFILE* %2)
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal void @write_2_bytes(i32 %val) #0 {
entry:
  %val.addr = alloca i32, align 4
  store i32 %val, i32* %val.addr, align 4
  %0 = load i32* %val.addr, align 4
  %shr = lshr i32 %0, 8
  %and = and i32 %shr, 255
  %1 = load %struct.__sFILE** @outfile, align 8
  %call = call i32 @putc(i32 %and, %struct.__sFILE* %1)
  %2 = load i32* %val.addr, align 4
  %and1 = and i32 %2, 255
  %3 = load %struct.__sFILE** @outfile, align 8
  %call2 = call i32 @putc(i32 %and1, %struct.__sFILE* %3)
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal void @write_1_byte(i32 %c) #0 {
entry:
  %c.addr = alloca i32, align 4
  store i32 %c, i32* %c.addr, align 4
  %0 = load i32* %c.addr, align 4
  %1 = load %struct.__sFILE** @outfile, align 8
  %call = call i32 @putc(i32 %0, %struct.__sFILE* %1)
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal void @copy_rest_of_file() #0 {
entry:
  %c = alloca i32, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load %struct.__sFILE** @infile, align 8
  %call = call i32 @getc(%struct.__sFILE* %0)
  store i32 %call, i32* %c, align 4
  %cmp = icmp ne i32 %call, -1
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load i32* %c, align 4
  %2 = load %struct.__sFILE** @outfile, align 8
  %call1 = call i32 @putc(i32 %1, %struct.__sFILE* %2)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

declare i32 @putc(i32, %struct.__sFILE*) #1

; Function Attrs: nounwind ssp uwtable
define internal i32 @first_marker() #0 {
entry:
  %c1 = alloca i32, align 4
  %c2 = alloca i32, align 4
  %0 = load %struct.__sFILE** @infile, align 8
  %call = call i32 @getc(%struct.__sFILE* %0)
  store i32 %call, i32* %c1, align 4
  %1 = load %struct.__sFILE** @infile, align 8
  %call1 = call i32 @getc(%struct.__sFILE* %1)
  store i32 %call1, i32* %c2, align 4
  %2 = load i32* %c1, align 4
  %cmp = icmp ne i32 %2, 255
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load i32* %c2, align 4
  %cmp2 = icmp ne i32 %3, 216
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %4 = load %struct.__sFILE** @__stderrp, align 8
  %call3 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %4, i8* getelementptr inbounds ([4 x i8]* @.str6, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8]* @.str18, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %lor.lhs.false
  %5 = load i32* %c2, align 4
  ret i32 %5
}

; Function Attrs: nounwind ssp uwtable
define internal i32 @next_marker() #0 {
entry:
  %c = alloca i32, align 4
  %discarded_bytes = alloca i32, align 4
  store i32 0, i32* %discarded_bytes, align 4
  %call = call i32 @read_1_byte()
  store i32 %call, i32* %c, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i32* %c, align 4
  %cmp = icmp ne i32 %0, 255
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load i32* %discarded_bytes, align 4
  %inc = add nsw i32 %1, 1
  store i32 %inc, i32* %discarded_bytes, align 4
  %call1 = call i32 @read_1_byte()
  store i32 %call1, i32* %c, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %do.body

do.body:                                          ; preds = %do.cond, %while.end
  %call2 = call i32 @read_1_byte()
  store i32 %call2, i32* %c, align 4
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %2 = load i32* %c, align 4
  %cmp3 = icmp eq i32 %2, 255
  br i1 %cmp3, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %3 = load i32* %discarded_bytes, align 4
  %cmp4 = icmp ne i32 %3, 0
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %do.end
  %4 = load %struct.__sFILE** @__stderrp, align 8
  %call5 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %4, i8* getelementptr inbounds ([42 x i8]* @.str17, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %do.end
  %5 = load i32* %c, align 4
  ret i32 %5
}

; Function Attrs: nounwind ssp uwtable
define internal void @copy_variable() #0 {
entry:
  %length = alloca i32, align 4
  %call = call i32 @read_2_bytes()
  store i32 %call, i32* %length, align 4
  %0 = load i32* %length, align 4
  call void @write_2_bytes(i32 %0)
  %1 = load i32* %length, align 4
  %cmp = icmp ult i32 %1, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.__sFILE** @__stderrp, align 8
  %call1 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %2, i8* getelementptr inbounds ([4 x i8]* @.str6, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8]* @.str15, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %3 = load i32* %length, align 4
  %sub = sub i32 %3, 2
  store i32 %sub, i32* %length, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %4 = load i32* %length, align 4
  %cmp2 = icmp ugt i32 %4, 0
  br i1 %cmp2, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %call3 = call i32 @read_1_byte()
  call void @write_1_byte(i32 %call3)
  %5 = load i32* %length, align 4
  %dec = add i32 %5, -1
  store i32 %dec, i32* %length, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal void @skip_variable() #0 {
entry:
  %length = alloca i32, align 4
  %call = call i32 @read_2_bytes()
  store i32 %call, i32* %length, align 4
  %0 = load i32* %length, align 4
  %cmp = icmp ult i32 %0, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.__sFILE** @__stderrp, align 8
  %call1 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %1, i8* getelementptr inbounds ([4 x i8]* @.str6, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8]* @.str15, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %2 = load i32* %length, align 4
  %sub = sub i32 %2, 2
  store i32 %sub, i32* %length, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %3 = load i32* %length, align 4
  %cmp2 = icmp ugt i32 %3, 0
  br i1 %cmp2, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %call3 = call i32 @read_1_byte()
  %4 = load i32* %length, align 4
  %dec = add i32 %4, -1
  store i32 %dec, i32* %length, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal i32 @read_2_bytes() #0 {
entry:
  %c1 = alloca i32, align 4
  %c2 = alloca i32, align 4
  %0 = load %struct.__sFILE** @infile, align 8
  %call = call i32 @getc(%struct.__sFILE* %0)
  store i32 %call, i32* %c1, align 4
  %1 = load i32* %c1, align 4
  %cmp = icmp eq i32 %1, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.__sFILE** @__stderrp, align 8
  %call1 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %2, i8* getelementptr inbounds ([4 x i8]* @.str6, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8]* @.str16, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %3 = load %struct.__sFILE** @infile, align 8
  %call2 = call i32 @getc(%struct.__sFILE* %3)
  store i32 %call2, i32* %c2, align 4
  %4 = load i32* %c2, align 4
  %cmp3 = icmp eq i32 %4, -1
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %5 = load %struct.__sFILE** @__stderrp, align 8
  %call5 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %5, i8* getelementptr inbounds ([4 x i8]* @.str6, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8]* @.str16, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end6:                                          ; preds = %if.end
  %6 = load i32* %c1, align 4
  %shl = shl i32 %6, 8
  %7 = load i32* %c2, align 4
  %add = add i32 %shl, %7
  ret i32 %add
}

; Function Attrs: nounwind ssp uwtable
define internal i32 @read_1_byte() #0 {
entry:
  %c = alloca i32, align 4
  %0 = load %struct.__sFILE** @infile, align 8
  %call = call i32 @getc(%struct.__sFILE* %0)
  store i32 %call, i32* %c, align 4
  %1 = load i32* %c, align 4
  %cmp = icmp eq i32 %1, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.__sFILE** @__stderrp, align 8
  %call1 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %2, i8* getelementptr inbounds ([4 x i8]* @.str6, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8]* @.str16, i32 0, i32 0))
  call void @exit(i32 1) #5
  unreachable

if.end:                                           ; preds = %entry
  %3 = load i32* %c, align 4
  ret i32 %3
}

declare i32 @isupper(i32) #1

declare i32 @tolower(i32) #1

attributes #0 = { nounwind ssp uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind readnone }
attributes #5 = { noreturn }
attributes #6 = { nounwind }
