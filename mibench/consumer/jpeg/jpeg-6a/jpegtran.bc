; ModuleID = 'jpegtran.c'
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-apple-macosx10.9.0"

%struct.__sFILE = type { i8*, i32, i32, i16, i16, %struct.__sbuf, i32, i8*, i32 (i8*)*, i32 (i8*, i8*, i32)*, i64 (i8*, i64, i32)*, i32 (i8*, i8*, i32)*, %struct.__sbuf, %struct.__sFILEX*, i32, [3 x i8], [1 x i8], %struct.__sbuf, i32, i64 }
%struct.__sbuf = type { i8*, i32 }
%struct.__sFILEX = type opaque
%struct.jpeg_decompress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_source_mgr*, i32, i32, i32, i32, i32, i32, i32, double, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8**, i32, i32, i32, i32, i32, [64 x i32]*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], i32, %struct.jpeg_component_info*, i32, i32, [16 x i8], [16 x i8], [16 x i8], i32, i32, i8, i16, i16, i32, i8, i32, i32, i32, i32, i32, i8*, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, i32, %struct.jpeg_decomp_master*, %struct.jpeg_d_main_controller*, %struct.jpeg_d_coef_controller*, %struct.jpeg_d_post_controller*, %struct.jpeg_input_controller*, %struct.jpeg_marker_reader*, %struct.jpeg_entropy_decoder*, %struct.jpeg_inverse_dct*, %struct.jpeg_upsampler*, %struct.jpeg_color_deconverter*, %struct.jpeg_color_quantizer* }
%struct.jpeg_error_mgr = type { void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*, i32)*, void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*, i8*)*, void (%struct.jpeg_common_struct*)*, i32, %union.anon, i32, i64, i8**, i32, i8**, i32, i32 }
%struct.jpeg_common_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32 }
%struct.jpeg_memory_mgr = type { i8* (%struct.jpeg_common_struct*, i32, i64)*, i8* (%struct.jpeg_common_struct*, i32, i64)*, i8** (%struct.jpeg_common_struct*, i32, i32, i32)*, [64 x i16]** (%struct.jpeg_common_struct*, i32, i32, i32)*, %struct.jvirt_sarray_control* (%struct.jpeg_common_struct*, i32, i32, i32, i32, i32)*, %struct.jvirt_barray_control* (%struct.jpeg_common_struct*, i32, i32, i32, i32, i32)*, {}*, i8** (%struct.jpeg_common_struct*, %struct.jvirt_sarray_control*, i32, i32, i32)*, [64 x i16]** (%struct.jpeg_common_struct*, %struct.jvirt_barray_control*, i32, i32, i32)*, void (%struct.jpeg_common_struct*, i32)*, {}*, i64 }
%struct.jvirt_sarray_control = type opaque
%struct.jvirt_barray_control = type opaque
%struct.jpeg_progress_mgr = type { {}*, i64, i64, i32, i32 }
%union.anon = type { [8 x i32], [48 x i8] }
%struct.jpeg_source_mgr = type { i8*, i64, void (%struct.jpeg_decompress_struct*)*, i32 (%struct.jpeg_decompress_struct*)*, void (%struct.jpeg_decompress_struct*, i64)*, i32 (%struct.jpeg_decompress_struct*, i32)*, void (%struct.jpeg_decompress_struct*)* }
%struct.JQUANT_TBL = type { [64 x i16], i32 }
%struct.JHUFF_TBL = type { [17 x i8], [256 x i8], i32 }
%struct.jpeg_component_info = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.JQUANT_TBL*, i8* }
%struct.jpeg_decomp_master = type opaque
%struct.jpeg_d_main_controller = type opaque
%struct.jpeg_d_coef_controller = type opaque
%struct.jpeg_d_post_controller = type opaque
%struct.jpeg_input_controller = type opaque
%struct.jpeg_marker_reader = type opaque
%struct.jpeg_entropy_decoder = type opaque
%struct.jpeg_inverse_dct = type opaque
%struct.jpeg_upsampler = type opaque
%struct.jpeg_color_deconverter = type opaque
%struct.jpeg_color_quantizer = type opaque
%struct.jpeg_compress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i32, i32, %struct.jpeg_destination_mgr*, i32, i32, i32, i32, double, i32, i32, i32, %struct.jpeg_component_info*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], [16 x i8], [16 x i8], [16 x i8], i32, %struct.jpeg_scan_info*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, i16, i16, i32, i32, i32, i32, i32, i32, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, %struct.jpeg_comp_master*, %struct.jpeg_c_main_controller*, %struct.jpeg_c_prep_controller*, %struct.jpeg_c_coef_controller*, %struct.jpeg_marker_writer*, %struct.jpeg_color_converter*, %struct.jpeg_downsampler*, %struct.jpeg_forward_dct*, %struct.jpeg_entropy_encoder* }
%struct.jpeg_destination_mgr = type { i8*, i64, void (%struct.jpeg_compress_struct*)*, i32 (%struct.jpeg_compress_struct*)*, void (%struct.jpeg_compress_struct*)* }
%struct.jpeg_scan_info = type { i32, [4 x i32], i32, i32, i32, i32 }
%struct.jpeg_comp_master = type opaque
%struct.jpeg_c_main_controller = type opaque
%struct.jpeg_c_prep_controller = type opaque
%struct.jpeg_c_coef_controller = type opaque
%struct.jpeg_marker_writer = type opaque
%struct.jpeg_color_converter = type opaque
%struct.jpeg_downsampler = type opaque
%struct.jpeg_forward_dct = type opaque
%struct.jpeg_entropy_encoder = type opaque

@progname = internal global i8* null, align 8
@.str = private unnamed_addr constant [9 x i8] c"jpegtran\00", align 1
@__stderrp = external global %struct.__sFILE*
@.str1 = private unnamed_addr constant [25 x i8] c"%s: only one input file\0A\00", align 1
@.str2 = private unnamed_addr constant [3 x i8] c"rb\00", align 1
@.str3 = private unnamed_addr constant [19 x i8] c"%s: can't open %s\0A\00", align 1
@outfilename = internal global i8* null, align 8
@.str4 = private unnamed_addr constant [3 x i8] c"wb\00", align 1
@__stdinp = external global %struct.__sFILE*
@__stdoutp = external global %struct.__sFILE*
@.str5 = private unnamed_addr constant [22 x i8] c"usage: %s [switches] \00", align 1
@.str6 = private unnamed_addr constant [13 x i8] c"[inputfile]\0A\00", align 1
@.str7 = private unnamed_addr constant [38 x i8] c"Switches (names may be abbreviated):\0A\00", align 1
@.str8 = private unnamed_addr constant [78 x i8] c"  -optimize      Optimize Huffman table (smaller file, but slow compression)\0A\00", align 1
@.str9 = private unnamed_addr constant [47 x i8] c"  -progressive   Create progressive JPEG file\0A\00", align 1
@.str10 = private unnamed_addr constant [30 x i8] c"Switches for advanced users:\0A\00", align 1
@.str11 = private unnamed_addr constant [68 x i8] c"  -restart N     Set restart interval in rows, or in blocks with B\0A\00", align 1
@.str12 = private unnamed_addr constant [52 x i8] c"  -maxmemory N   Maximum memory to use (in kbytes)\0A\00", align 1
@.str13 = private unnamed_addr constant [47 x i8] c"  -outfile name  Specify name for output file\0A\00", align 1
@.str14 = private unnamed_addr constant [44 x i8] c"  -verbose  or  -debug   Emit debug output\0A\00", align 1
@.str15 = private unnamed_addr constant [23 x i8] c"Switches for wizards:\0A\00", align 1
@.str16 = private unnamed_addr constant [57 x i8] c"  -scans file    Create multi-scan JPEG per script file\0A\00", align 1
@.str17 = private unnamed_addr constant [11 x i8] c"arithmetic\00", align 1
@.str18 = private unnamed_addr constant [44 x i8] c"%s: sorry, arithmetic coding not supported\0A\00", align 1
@.str19 = private unnamed_addr constant [6 x i8] c"debug\00", align 1
@.str20 = private unnamed_addr constant [8 x i8] c"verbose\00", align 1
@parse_switches.printed_version = internal global i32 0, align 4
@.str21 = private unnamed_addr constant [50 x i8] c"Independent JPEG Group's JPEGTRAN, version %s\0A%s\0A\00", align 1
@.str22 = private unnamed_addr constant [13 x i8] c"6a  7-Feb-96\00", align 1
@.str23 = private unnamed_addr constant [35 x i8] c"Copyright (C) 1996, Thomas G. Lane\00", align 1
@.str24 = private unnamed_addr constant [10 x i8] c"maxmemory\00", align 1
@.str25 = private unnamed_addr constant [6 x i8] c"%ld%c\00", align 1
@.str26 = private unnamed_addr constant [9 x i8] c"optimize\00", align 1
@.str27 = private unnamed_addr constant [9 x i8] c"optimise\00", align 1
@.str28 = private unnamed_addr constant [8 x i8] c"outfile\00", align 1
@.str29 = private unnamed_addr constant [12 x i8] c"progressive\00", align 1
@.str30 = private unnamed_addr constant [8 x i8] c"restart\00", align 1
@.str31 = private unnamed_addr constant [6 x i8] c"scans\00", align 1

; Function Attrs: nounwind ssp uwtable
define i32 @main(i32 %argc, i8** %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  %srcinfo = alloca %struct.jpeg_decompress_struct, align 8
  %dstinfo = alloca %struct.jpeg_compress_struct, align 8
  %jsrcerr = alloca %struct.jpeg_error_mgr, align 8
  %jdsterr = alloca %struct.jpeg_error_mgr, align 8
  %coef_arrays = alloca %struct.jvirt_barray_control**, align 8
  %file_index = alloca i32, align 4
  %input_file = alloca %struct.__sFILE*, align 8
  %output_file = alloca %struct.__sFILE*, align 8
  store i32 0, i32* %retval
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  %0 = load i8*** %argv.addr, align 8
  %arrayidx = getelementptr inbounds i8** %0, i64 0
  %1 = load i8** %arrayidx, align 8
  store i8* %1, i8** @progname, align 8
  %2 = load i8** @progname, align 8
  %cmp = icmp eq i8* %2, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load i8** @progname, align 8
  %arrayidx1 = getelementptr inbounds i8* %3, i64 0
  %4 = load i8* %arrayidx1, align 1
  %conv = sext i8 %4 to i32
  %cmp2 = icmp eq i32 %conv, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i8* getelementptr inbounds ([9 x i8]* @.str, i32 0, i32 0), i8** @progname, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %call = call %struct.jpeg_error_mgr* @jpeg_std_error(%struct.jpeg_error_mgr* %jsrcerr)
  %err = getelementptr inbounds %struct.jpeg_decompress_struct* %srcinfo, i32 0, i32 0
  store %struct.jpeg_error_mgr* %call, %struct.jpeg_error_mgr** %err, align 8
  call void @jpeg_CreateDecompress(%struct.jpeg_decompress_struct* %srcinfo, i32 61, i64 616)
  %call4 = call %struct.jpeg_error_mgr* @jpeg_std_error(%struct.jpeg_error_mgr* %jdsterr)
  %err5 = getelementptr inbounds %struct.jpeg_compress_struct* %dstinfo, i32 0, i32 0
  store %struct.jpeg_error_mgr* %call4, %struct.jpeg_error_mgr** %err5, align 8
  call void @jpeg_CreateCompress(%struct.jpeg_compress_struct* %dstinfo, i32 61, i64 496)
  %5 = load i32* %argc.addr, align 4
  %6 = load i8*** %argv.addr, align 8
  %call6 = call i32 @parse_switches(%struct.jpeg_compress_struct* %dstinfo, i32 %5, i8** %6, i32 0, i32 0)
  store i32 %call6, i32* %file_index, align 4
  %trace_level = getelementptr inbounds %struct.jpeg_error_mgr* %jdsterr, i32 0, i32 7
  %7 = load i32* %trace_level, align 4
  %trace_level7 = getelementptr inbounds %struct.jpeg_error_mgr* %jsrcerr, i32 0, i32 7
  store i32 %7, i32* %trace_level7, align 4
  %mem = getelementptr inbounds %struct.jpeg_compress_struct* %dstinfo, i32 0, i32 1
  %8 = load %struct.jpeg_memory_mgr** %mem, align 8
  %max_memory_to_use = getelementptr inbounds %struct.jpeg_memory_mgr* %8, i32 0, i32 11
  %9 = load i64* %max_memory_to_use, align 8
  %mem8 = getelementptr inbounds %struct.jpeg_decompress_struct* %srcinfo, i32 0, i32 1
  %10 = load %struct.jpeg_memory_mgr** %mem8, align 8
  %max_memory_to_use9 = getelementptr inbounds %struct.jpeg_memory_mgr* %10, i32 0, i32 11
  store i64 %9, i64* %max_memory_to_use9, align 8
  %11 = load i32* %file_index, align 4
  %12 = load i32* %argc.addr, align 4
  %sub = sub nsw i32 %12, 1
  %cmp10 = icmp slt i32 %11, %sub
  br i1 %cmp10, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end
  %13 = load %struct.__sFILE** @__stderrp, align 8
  %14 = load i8** @progname, align 8
  %call13 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %13, i8* getelementptr inbounds ([25 x i8]* @.str1, i32 0, i32 0), i8* %14)
  call void @usage()
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %if.end
  %15 = load i32* %file_index, align 4
  %16 = load i32* %argc.addr, align 4
  %cmp15 = icmp slt i32 %15, %16
  br i1 %cmp15, label %if.then17, label %if.else

if.then17:                                        ; preds = %if.end14
  %17 = load i32* %file_index, align 4
  %idxprom = sext i32 %17 to i64
  %18 = load i8*** %argv.addr, align 8
  %arrayidx18 = getelementptr inbounds i8** %18, i64 %idxprom
  %19 = load i8** %arrayidx18, align 8
  %call19 = call %struct.__sFILE* @"\01_fopen"(i8* %19, i8* getelementptr inbounds ([3 x i8]* @.str2, i32 0, i32 0))
  store %struct.__sFILE* %call19, %struct.__sFILE** %input_file, align 8
  %cmp20 = icmp eq %struct.__sFILE* %call19, null
  br i1 %cmp20, label %if.then22, label %if.end26

if.then22:                                        ; preds = %if.then17
  %20 = load %struct.__sFILE** @__stderrp, align 8
  %21 = load i8** @progname, align 8
  %22 = load i32* %file_index, align 4
  %idxprom23 = sext i32 %22 to i64
  %23 = load i8*** %argv.addr, align 8
  %arrayidx24 = getelementptr inbounds i8** %23, i64 %idxprom23
  %24 = load i8** %arrayidx24, align 8
  %call25 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %20, i8* getelementptr inbounds ([19 x i8]* @.str3, i32 0, i32 0), i8* %21, i8* %24)
  call void @exit(i32 1) #3
  unreachable

if.end26:                                         ; preds = %if.then17
  br label %if.end28

if.else:                                          ; preds = %if.end14
  %call27 = call %struct.__sFILE* @read_stdin()
  store %struct.__sFILE* %call27, %struct.__sFILE** %input_file, align 8
  br label %if.end28

if.end28:                                         ; preds = %if.else, %if.end26
  %25 = load i8** @outfilename, align 8
  %cmp29 = icmp ne i8* %25, null
  br i1 %cmp29, label %if.then31, label %if.else38

if.then31:                                        ; preds = %if.end28
  %26 = load i8** @outfilename, align 8
  %call32 = call %struct.__sFILE* @"\01_fopen"(i8* %26, i8* getelementptr inbounds ([3 x i8]* @.str4, i32 0, i32 0))
  store %struct.__sFILE* %call32, %struct.__sFILE** %output_file, align 8
  %cmp33 = icmp eq %struct.__sFILE* %call32, null
  br i1 %cmp33, label %if.then35, label %if.end37

if.then35:                                        ; preds = %if.then31
  %27 = load %struct.__sFILE** @__stderrp, align 8
  %28 = load i8** @progname, align 8
  %29 = load i8** @outfilename, align 8
  %call36 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %27, i8* getelementptr inbounds ([19 x i8]* @.str3, i32 0, i32 0), i8* %28, i8* %29)
  call void @exit(i32 1) #3
  unreachable

if.end37:                                         ; preds = %if.then31
  br label %if.end40

if.else38:                                        ; preds = %if.end28
  %call39 = call %struct.__sFILE* @write_stdout()
  store %struct.__sFILE* %call39, %struct.__sFILE** %output_file, align 8
  br label %if.end40

if.end40:                                         ; preds = %if.else38, %if.end37
  %30 = load %struct.__sFILE** %input_file, align 8
  call void @jpeg_stdio_src(%struct.jpeg_decompress_struct* %srcinfo, %struct.__sFILE* %30)
  %call41 = call i32 @jpeg_read_header(%struct.jpeg_decompress_struct* %srcinfo, i32 1)
  %call42 = call %struct.jvirt_barray_control** @jpeg_read_coefficients(%struct.jpeg_decompress_struct* %srcinfo)
  store %struct.jvirt_barray_control** %call42, %struct.jvirt_barray_control*** %coef_arrays, align 8
  call void @jpeg_copy_critical_parameters(%struct.jpeg_decompress_struct* %srcinfo, %struct.jpeg_compress_struct* %dstinfo)
  %31 = load i32* %argc.addr, align 4
  %32 = load i8*** %argv.addr, align 8
  %call43 = call i32 @parse_switches(%struct.jpeg_compress_struct* %dstinfo, i32 %31, i8** %32, i32 0, i32 1)
  store i32 %call43, i32* %file_index, align 4
  %33 = load %struct.__sFILE** %output_file, align 8
  call void @jpeg_stdio_dest(%struct.jpeg_compress_struct* %dstinfo, %struct.__sFILE* %33)
  %34 = load %struct.jvirt_barray_control*** %coef_arrays, align 8
  call void @jpeg_write_coefficients(%struct.jpeg_compress_struct* %dstinfo, %struct.jvirt_barray_control** %34)
  call void @jpeg_finish_compress(%struct.jpeg_compress_struct* %dstinfo)
  call void @jpeg_destroy_compress(%struct.jpeg_compress_struct* %dstinfo)
  %call44 = call i32 @jpeg_finish_decompress(%struct.jpeg_decompress_struct* %srcinfo)
  call void @jpeg_destroy_decompress(%struct.jpeg_decompress_struct* %srcinfo)
  %35 = load %struct.__sFILE** %input_file, align 8
  %36 = load %struct.__sFILE** @__stdinp, align 8
  %cmp45 = icmp ne %struct.__sFILE* %35, %36
  br i1 %cmp45, label %if.then47, label %if.end49

if.then47:                                        ; preds = %if.end40
  %37 = load %struct.__sFILE** %input_file, align 8
  %call48 = call i32 @fclose(%struct.__sFILE* %37)
  br label %if.end49

if.end49:                                         ; preds = %if.then47, %if.end40
  %38 = load %struct.__sFILE** %output_file, align 8
  %39 = load %struct.__sFILE** @__stdoutp, align 8
  %cmp50 = icmp ne %struct.__sFILE* %38, %39
  br i1 %cmp50, label %if.then52, label %if.end54

if.then52:                                        ; preds = %if.end49
  %40 = load %struct.__sFILE** %output_file, align 8
  %call53 = call i32 @fclose(%struct.__sFILE* %40)
  br label %if.end54

if.end54:                                         ; preds = %if.then52, %if.end49
  %num_warnings = getelementptr inbounds %struct.jpeg_error_mgr* %jsrcerr, i32 0, i32 8
  %41 = load i64* %num_warnings, align 8
  %num_warnings55 = getelementptr inbounds %struct.jpeg_error_mgr* %jdsterr, i32 0, i32 8
  %42 = load i64* %num_warnings55, align 8
  %add = add nsw i64 %41, %42
  %tobool = icmp ne i64 %add, 0
  %cond = select i1 %tobool, i32 2, i32 0
  call void @exit(i32 %cond) #3
  unreachable

return:                                           ; No predecessors!
  %43 = load i32* %retval
  ret i32 %43
}

declare %struct.jpeg_error_mgr* @jpeg_std_error(%struct.jpeg_error_mgr*) #1

declare void @jpeg_CreateDecompress(%struct.jpeg_decompress_struct*, i32, i64) #1

declare void @jpeg_CreateCompress(%struct.jpeg_compress_struct*, i32, i64) #1

; Function Attrs: nounwind ssp uwtable
define internal i32 @parse_switches(%struct.jpeg_compress_struct* %cinfo, i32 %argc, i8** %argv, i32 %last_file_arg_seen, i32 %for_real) #0 {
entry:
  %cinfo.addr = alloca %struct.jpeg_compress_struct*, align 8
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  %last_file_arg_seen.addr = alloca i32, align 4
  %for_real.addr = alloca i32, align 4
  %argn = alloca i32, align 4
  %arg = alloca i8*, align 8
  %simple_progressive = alloca i32, align 4
  %scansarg = alloca i8*, align 8
  %lval = alloca i64, align 8
  %ch = alloca i8, align 1
  %lval72 = alloca i64, align 8
  %ch73 = alloca i8, align 1
  store %struct.jpeg_compress_struct* %cinfo, %struct.jpeg_compress_struct** %cinfo.addr, align 8
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  store i32 %last_file_arg_seen, i32* %last_file_arg_seen.addr, align 4
  store i32 %for_real, i32* %for_real.addr, align 4
  store i8* null, i8** %scansarg, align 8
  store i32 0, i32* %simple_progressive, align 4
  store i8* null, i8** @outfilename, align 8
  %0 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %err = getelementptr inbounds %struct.jpeg_compress_struct* %0, i32 0, i32 0
  %1 = load %struct.jpeg_error_mgr** %err, align 8
  %trace_level = getelementptr inbounds %struct.jpeg_error_mgr* %1, i32 0, i32 7
  store i32 0, i32* %trace_level, align 4
  store i32 1, i32* %argn, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32* %argn, align 4
  %3 = load i32* %argc.addr, align 4
  %cmp = icmp slt i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i32* %argn, align 4
  %idxprom = sext i32 %4 to i64
  %5 = load i8*** %argv.addr, align 8
  %arrayidx = getelementptr inbounds i8** %5, i64 %idxprom
  %6 = load i8** %arrayidx, align 8
  store i8* %6, i8** %arg, align 8
  %7 = load i8** %arg, align 8
  %8 = load i8* %7, align 1
  %conv = sext i8 %8 to i32
  %cmp1 = icmp ne i32 %conv, 45
  br i1 %cmp1, label %if.then, label %if.end6

if.then:                                          ; preds = %for.body
  %9 = load i32* %argn, align 4
  %10 = load i32* %last_file_arg_seen.addr, align 4
  %cmp3 = icmp sle i32 %9, %10
  br i1 %cmp3, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.then
  store i8* null, i8** @outfilename, align 8
  br label %for.inc

if.end:                                           ; preds = %if.then
  br label %for.end

if.end6:                                          ; preds = %for.body
  %11 = load i8** %arg, align 8
  %incdec.ptr = getelementptr inbounds i8* %11, i32 1
  store i8* %incdec.ptr, i8** %arg, align 8
  %12 = load i8** %arg, align 8
  %call = call i32 @keymatch(i8* %12, i8* getelementptr inbounds ([11 x i8]* @.str17, i32 0, i32 0), i32 1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then7, label %if.else

if.then7:                                         ; preds = %if.end6
  %13 = load %struct.__sFILE** @__stderrp, align 8
  %14 = load i8** @progname, align 8
  %call8 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %13, i8* getelementptr inbounds ([44 x i8]* @.str18, i32 0, i32 0), i8* %14)
  call void @exit(i32 1) #3
  unreachable

if.else:                                          ; preds = %if.end6
  %15 = load i8** %arg, align 8
  %call9 = call i32 @keymatch(i8* %15, i8* getelementptr inbounds ([6 x i8]* @.str19, i32 0, i32 0), i32 1)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.then13, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %16 = load i8** %arg, align 8
  %call11 = call i32 @keymatch(i8* %16, i8* getelementptr inbounds ([8 x i8]* @.str20, i32 0, i32 0), i32 1)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.then13, label %if.else20

if.then13:                                        ; preds = %lor.lhs.false, %if.else
  %17 = load i32* @parse_switches.printed_version, align 4
  %tobool14 = icmp ne i32 %17, 0
  br i1 %tobool14, label %if.end17, label %if.then15

if.then15:                                        ; preds = %if.then13
  %18 = load %struct.__sFILE** @__stderrp, align 8
  %call16 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %18, i8* getelementptr inbounds ([50 x i8]* @.str21, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8]* @.str22, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8]* @.str23, i32 0, i32 0))
  store i32 1, i32* @parse_switches.printed_version, align 4
  br label %if.end17

if.end17:                                         ; preds = %if.then15, %if.then13
  %19 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %err18 = getelementptr inbounds %struct.jpeg_compress_struct* %19, i32 0, i32 0
  %20 = load %struct.jpeg_error_mgr** %err18, align 8
  %trace_level19 = getelementptr inbounds %struct.jpeg_error_mgr* %20, i32 0, i32 7
  %21 = load i32* %trace_level19, align 4
  %inc = add nsw i32 %21, 1
  store i32 %inc, i32* %trace_level19, align 4
  br label %if.end124

if.else20:                                        ; preds = %lor.lhs.false
  %22 = load i8** %arg, align 8
  %call21 = call i32 @keymatch(i8* %22, i8* getelementptr inbounds ([10 x i8]* @.str24, i32 0, i32 0), i32 3)
  %tobool22 = icmp ne i32 %call21, 0
  br i1 %tobool22, label %if.then23, label %if.else46

if.then23:                                        ; preds = %if.else20
  store i8 120, i8* %ch, align 1
  %23 = load i32* %argn, align 4
  %inc24 = add nsw i32 %23, 1
  store i32 %inc24, i32* %argn, align 4
  %24 = load i32* %argc.addr, align 4
  %cmp25 = icmp sge i32 %inc24, %24
  br i1 %cmp25, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.then23
  call void @usage()
  br label %if.end28

if.end28:                                         ; preds = %if.then27, %if.then23
  %25 = load i32* %argn, align 4
  %idxprom29 = sext i32 %25 to i64
  %26 = load i8*** %argv.addr, align 8
  %arrayidx30 = getelementptr inbounds i8** %26, i64 %idxprom29
  %27 = load i8** %arrayidx30, align 8
  %call31 = call i32 (i8*, i8*, ...)* @sscanf(i8* %27, i8* getelementptr inbounds ([6 x i8]* @.str25, i32 0, i32 0), i64* %lval, i8* %ch)
  %cmp32 = icmp slt i32 %call31, 1
  br i1 %cmp32, label %if.then34, label %if.end35

if.then34:                                        ; preds = %if.end28
  call void @usage()
  br label %if.end35

if.end35:                                         ; preds = %if.then34, %if.end28
  %28 = load i8* %ch, align 1
  %conv36 = sext i8 %28 to i32
  %cmp37 = icmp eq i32 %conv36, 109
  br i1 %cmp37, label %if.then43, label %lor.lhs.false39

lor.lhs.false39:                                  ; preds = %if.end35
  %29 = load i8* %ch, align 1
  %conv40 = sext i8 %29 to i32
  %cmp41 = icmp eq i32 %conv40, 77
  br i1 %cmp41, label %if.then43, label %if.end44

if.then43:                                        ; preds = %lor.lhs.false39, %if.end35
  %30 = load i64* %lval, align 8
  %mul = mul nsw i64 %30, 1000
  store i64 %mul, i64* %lval, align 8
  br label %if.end44

if.end44:                                         ; preds = %if.then43, %lor.lhs.false39
  %31 = load i64* %lval, align 8
  %mul45 = mul nsw i64 %31, 1000
  %32 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %mem = getelementptr inbounds %struct.jpeg_compress_struct* %32, i32 0, i32 1
  %33 = load %struct.jpeg_memory_mgr** %mem, align 8
  %max_memory_to_use = getelementptr inbounds %struct.jpeg_memory_mgr* %33, i32 0, i32 11
  store i64 %mul45, i64* %max_memory_to_use, align 8
  br label %if.end123

if.else46:                                        ; preds = %if.else20
  %34 = load i8** %arg, align 8
  %call47 = call i32 @keymatch(i8* %34, i8* getelementptr inbounds ([9 x i8]* @.str26, i32 0, i32 0), i32 1)
  %tobool48 = icmp ne i32 %call47, 0
  br i1 %tobool48, label %if.then52, label %lor.lhs.false49

lor.lhs.false49:                                  ; preds = %if.else46
  %35 = load i8** %arg, align 8
  %call50 = call i32 @keymatch(i8* %35, i8* getelementptr inbounds ([9 x i8]* @.str27, i32 0, i32 0), i32 1)
  %tobool51 = icmp ne i32 %call50, 0
  br i1 %tobool51, label %if.then52, label %if.else53

if.then52:                                        ; preds = %lor.lhs.false49, %if.else46
  %36 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %optimize_coding = getelementptr inbounds %struct.jpeg_compress_struct* %36, i32 0, i32 25
  store i32 1, i32* %optimize_coding, align 4
  br label %if.end122

if.else53:                                        ; preds = %lor.lhs.false49
  %37 = load i8** %arg, align 8
  %call54 = call i32 @keymatch(i8* %37, i8* getelementptr inbounds ([8 x i8]* @.str28, i32 0, i32 0), i32 4)
  %tobool55 = icmp ne i32 %call54, 0
  br i1 %tobool55, label %if.then56, label %if.else64

if.then56:                                        ; preds = %if.else53
  %38 = load i32* %argn, align 4
  %inc57 = add nsw i32 %38, 1
  store i32 %inc57, i32* %argn, align 4
  %39 = load i32* %argc.addr, align 4
  %cmp58 = icmp sge i32 %inc57, %39
  br i1 %cmp58, label %if.then60, label %if.end61

if.then60:                                        ; preds = %if.then56
  call void @usage()
  br label %if.end61

if.end61:                                         ; preds = %if.then60, %if.then56
  %40 = load i32* %argn, align 4
  %idxprom62 = sext i32 %40 to i64
  %41 = load i8*** %argv.addr, align 8
  %arrayidx63 = getelementptr inbounds i8** %41, i64 %idxprom62
  %42 = load i8** %arrayidx63, align 8
  store i8* %42, i8** @outfilename, align 8
  br label %if.end121

if.else64:                                        ; preds = %if.else53
  %43 = load i8** %arg, align 8
  %call65 = call i32 @keymatch(i8* %43, i8* getelementptr inbounds ([12 x i8]* @.str29, i32 0, i32 0), i32 1)
  %tobool66 = icmp ne i32 %call65, 0
  br i1 %tobool66, label %if.then67, label %if.else68

if.then67:                                        ; preds = %if.else64
  store i32 1, i32* %simple_progressive, align 4
  br label %if.end120

if.else68:                                        ; preds = %if.else64
  %44 = load i8** %arg, align 8
  %call69 = call i32 @keymatch(i8* %44, i8* getelementptr inbounds ([8 x i8]* @.str30, i32 0, i32 0), i32 1)
  %tobool70 = icmp ne i32 %call69, 0
  br i1 %tobool70, label %if.then71, label %if.else106

if.then71:                                        ; preds = %if.else68
  store i8 120, i8* %ch73, align 1
  %45 = load i32* %argn, align 4
  %inc74 = add nsw i32 %45, 1
  store i32 %inc74, i32* %argn, align 4
  %46 = load i32* %argc.addr, align 4
  %cmp75 = icmp sge i32 %inc74, %46
  br i1 %cmp75, label %if.then77, label %if.end78

if.then77:                                        ; preds = %if.then71
  call void @usage()
  br label %if.end78

if.end78:                                         ; preds = %if.then77, %if.then71
  %47 = load i32* %argn, align 4
  %idxprom79 = sext i32 %47 to i64
  %48 = load i8*** %argv.addr, align 8
  %arrayidx80 = getelementptr inbounds i8** %48, i64 %idxprom79
  %49 = load i8** %arrayidx80, align 8
  %call81 = call i32 (i8*, i8*, ...)* @sscanf(i8* %49, i8* getelementptr inbounds ([6 x i8]* @.str25, i32 0, i32 0), i64* %lval72, i8* %ch73)
  %cmp82 = icmp slt i32 %call81, 1
  br i1 %cmp82, label %if.then84, label %if.end85

if.then84:                                        ; preds = %if.end78
  call void @usage()
  br label %if.end85

if.end85:                                         ; preds = %if.then84, %if.end78
  %50 = load i64* %lval72, align 8
  %cmp86 = icmp slt i64 %50, 0
  br i1 %cmp86, label %if.then91, label %lor.lhs.false88

lor.lhs.false88:                                  ; preds = %if.end85
  %51 = load i64* %lval72, align 8
  %cmp89 = icmp sgt i64 %51, 65535
  br i1 %cmp89, label %if.then91, label %if.end92

if.then91:                                        ; preds = %lor.lhs.false88, %if.end85
  call void @usage()
  br label %if.end92

if.end92:                                         ; preds = %if.then91, %lor.lhs.false88
  %52 = load i8* %ch73, align 1
  %conv93 = sext i8 %52 to i32
  %cmp94 = icmp eq i32 %conv93, 98
  br i1 %cmp94, label %if.then100, label %lor.lhs.false96

lor.lhs.false96:                                  ; preds = %if.end92
  %53 = load i8* %ch73, align 1
  %conv97 = sext i8 %53 to i32
  %cmp98 = icmp eq i32 %conv97, 66
  br i1 %cmp98, label %if.then100, label %if.else102

if.then100:                                       ; preds = %lor.lhs.false96, %if.end92
  %54 = load i64* %lval72, align 8
  %conv101 = trunc i64 %54 to i32
  %55 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %restart_interval = getelementptr inbounds %struct.jpeg_compress_struct* %55, i32 0, i32 29
  store i32 %conv101, i32* %restart_interval, align 4
  %56 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %restart_in_rows = getelementptr inbounds %struct.jpeg_compress_struct* %56, i32 0, i32 30
  store i32 0, i32* %restart_in_rows, align 4
  br label %if.end105

if.else102:                                       ; preds = %lor.lhs.false96
  %57 = load i64* %lval72, align 8
  %conv103 = trunc i64 %57 to i32
  %58 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %restart_in_rows104 = getelementptr inbounds %struct.jpeg_compress_struct* %58, i32 0, i32 30
  store i32 %conv103, i32* %restart_in_rows104, align 4
  br label %if.end105

if.end105:                                        ; preds = %if.else102, %if.then100
  br label %if.end119

if.else106:                                       ; preds = %if.else68
  %59 = load i8** %arg, align 8
  %call107 = call i32 @keymatch(i8* %59, i8* getelementptr inbounds ([6 x i8]* @.str31, i32 0, i32 0), i32 2)
  %tobool108 = icmp ne i32 %call107, 0
  br i1 %tobool108, label %if.then109, label %if.else117

if.then109:                                       ; preds = %if.else106
  %60 = load i32* %argn, align 4
  %inc110 = add nsw i32 %60, 1
  store i32 %inc110, i32* %argn, align 4
  %61 = load i32* %argc.addr, align 4
  %cmp111 = icmp sge i32 %inc110, %61
  br i1 %cmp111, label %if.then113, label %if.end114

if.then113:                                       ; preds = %if.then109
  call void @usage()
  br label %if.end114

if.end114:                                        ; preds = %if.then113, %if.then109
  %62 = load i32* %argn, align 4
  %idxprom115 = sext i32 %62 to i64
  %63 = load i8*** %argv.addr, align 8
  %arrayidx116 = getelementptr inbounds i8** %63, i64 %idxprom115
  %64 = load i8** %arrayidx116, align 8
  store i8* %64, i8** %scansarg, align 8
  br label %if.end118

if.else117:                                       ; preds = %if.else106
  call void @usage()
  br label %if.end118

if.end118:                                        ; preds = %if.else117, %if.end114
  br label %if.end119

if.end119:                                        ; preds = %if.end118, %if.end105
  br label %if.end120

if.end120:                                        ; preds = %if.end119, %if.then67
  br label %if.end121

if.end121:                                        ; preds = %if.end120, %if.end61
  br label %if.end122

if.end122:                                        ; preds = %if.end121, %if.then52
  br label %if.end123

if.end123:                                        ; preds = %if.end122, %if.end44
  br label %if.end124

if.end124:                                        ; preds = %if.end123, %if.end17
  br label %if.end125

if.end125:                                        ; preds = %if.end124
  br label %for.inc

for.inc:                                          ; preds = %if.end125, %if.then5
  %65 = load i32* %argn, align 4
  %inc126 = add nsw i32 %65, 1
  store i32 %inc126, i32* %argn, align 4
  br label %for.cond

for.end:                                          ; preds = %if.end, %for.cond
  %66 = load i32* %for_real.addr, align 4
  %tobool127 = icmp ne i32 %66, 0
  br i1 %tobool127, label %if.then128, label %if.end140

if.then128:                                       ; preds = %for.end
  %67 = load i32* %simple_progressive, align 4
  %tobool129 = icmp ne i32 %67, 0
  br i1 %tobool129, label %if.then130, label %if.end131

if.then130:                                       ; preds = %if.then128
  %68 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  call void @jpeg_simple_progression(%struct.jpeg_compress_struct* %68)
  br label %if.end131

if.end131:                                        ; preds = %if.then130, %if.then128
  %69 = load i8** %scansarg, align 8
  %cmp132 = icmp ne i8* %69, null
  br i1 %cmp132, label %if.then134, label %if.end139

if.then134:                                       ; preds = %if.end131
  %70 = load %struct.jpeg_compress_struct** %cinfo.addr, align 8
  %71 = load i8** %scansarg, align 8
  %call135 = call i32 @read_scan_script(%struct.jpeg_compress_struct* %70, i8* %71)
  %tobool136 = icmp ne i32 %call135, 0
  br i1 %tobool136, label %if.end138, label %if.then137

if.then137:                                       ; preds = %if.then134
  call void @usage()
  br label %if.end138

if.end138:                                        ; preds = %if.then137, %if.then134
  br label %if.end139

if.end139:                                        ; preds = %if.end138, %if.end131
  br label %if.end140

if.end140:                                        ; preds = %if.end139, %for.end
  %72 = load i32* %argn, align 4
  ret i32 %72
}

declare i32 @fprintf(%struct.__sFILE*, i8*, ...) #1

; Function Attrs: nounwind ssp uwtable
define internal void @usage() #0 {
entry:
  %0 = load %struct.__sFILE** @__stderrp, align 8
  %1 = load i8** @progname, align 8
  %call = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %0, i8* getelementptr inbounds ([22 x i8]* @.str5, i32 0, i32 0), i8* %1)
  %2 = load %struct.__sFILE** @__stderrp, align 8
  %call1 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %2, i8* getelementptr inbounds ([13 x i8]* @.str6, i32 0, i32 0))
  %3 = load %struct.__sFILE** @__stderrp, align 8
  %call2 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %3, i8* getelementptr inbounds ([38 x i8]* @.str7, i32 0, i32 0))
  %4 = load %struct.__sFILE** @__stderrp, align 8
  %call3 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %4, i8* getelementptr inbounds ([78 x i8]* @.str8, i32 0, i32 0))
  %5 = load %struct.__sFILE** @__stderrp, align 8
  %call4 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %5, i8* getelementptr inbounds ([47 x i8]* @.str9, i32 0, i32 0))
  %6 = load %struct.__sFILE** @__stderrp, align 8
  %call5 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %6, i8* getelementptr inbounds ([30 x i8]* @.str10, i32 0, i32 0))
  %7 = load %struct.__sFILE** @__stderrp, align 8
  %call6 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %7, i8* getelementptr inbounds ([68 x i8]* @.str11, i32 0, i32 0))
  %8 = load %struct.__sFILE** @__stderrp, align 8
  %call7 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %8, i8* getelementptr inbounds ([52 x i8]* @.str12, i32 0, i32 0))
  %9 = load %struct.__sFILE** @__stderrp, align 8
  %call8 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %9, i8* getelementptr inbounds ([47 x i8]* @.str13, i32 0, i32 0))
  %10 = load %struct.__sFILE** @__stderrp, align 8
  %call9 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %10, i8* getelementptr inbounds ([44 x i8]* @.str14, i32 0, i32 0))
  %11 = load %struct.__sFILE** @__stderrp, align 8
  %call10 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %11, i8* getelementptr inbounds ([23 x i8]* @.str15, i32 0, i32 0))
  %12 = load %struct.__sFILE** @__stderrp, align 8
  %call11 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %12, i8* getelementptr inbounds ([57 x i8]* @.str16, i32 0, i32 0))
  call void @exit(i32 1) #3
  unreachable

return:                                           ; No predecessors!
  ret void
}

declare %struct.__sFILE* @"\01_fopen"(i8*, i8*) #1

; Function Attrs: noreturn
declare void @exit(i32) #2

declare %struct.__sFILE* @read_stdin() #1

declare %struct.__sFILE* @write_stdout() #1

declare void @jpeg_stdio_src(%struct.jpeg_decompress_struct*, %struct.__sFILE*) #1

declare i32 @jpeg_read_header(%struct.jpeg_decompress_struct*, i32) #1

declare %struct.jvirt_barray_control** @jpeg_read_coefficients(%struct.jpeg_decompress_struct*) #1

declare void @jpeg_copy_critical_parameters(%struct.jpeg_decompress_struct*, %struct.jpeg_compress_struct*) #1

declare void @jpeg_stdio_dest(%struct.jpeg_compress_struct*, %struct.__sFILE*) #1

declare void @jpeg_write_coefficients(%struct.jpeg_compress_struct*, %struct.jvirt_barray_control**) #1

declare void @jpeg_finish_compress(%struct.jpeg_compress_struct*) #1

declare void @jpeg_destroy_compress(%struct.jpeg_compress_struct*) #1

declare i32 @jpeg_finish_decompress(%struct.jpeg_decompress_struct*) #1

declare void @jpeg_destroy_decompress(%struct.jpeg_decompress_struct*) #1

declare i32 @fclose(%struct.__sFILE*) #1

declare i32 @keymatch(i8*, i8*, i32) #1

declare i32 @sscanf(i8*, i8*, ...) #1

declare void @jpeg_simple_progression(%struct.jpeg_compress_struct*) #1

declare i32 @read_scan_script(%struct.jpeg_compress_struct*, i8*) #1

attributes #0 = { nounwind ssp uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { noreturn }
